<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>pfan博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="pfan博客 新起点，新高度">
<meta property="og:type" content="website">
<meta property="og:title" content="pfan博客">
<meta property="og:url" content="http://pfan123.github.io/page/2/index.html">
<meta property="og:site_name" content="pfan博客">
<meta property="og:description" content="pfan博客 新起点，新高度">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="pfan博客">
<meta name="twitter:description" content="pfan博客 新起点，新高度">
  
    <link rel="alternative" href="/atom.xml" title="pfan博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://litten.github.io/assets/blogImg/litten.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">pfan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">新起点，新高度</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>		
					
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>A propos</li>
						
					</ul>
				</div>

			</div>
		


		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
				        	<li class = "article_cate_tit"> 文章分类</li>
				        	<li class = "article_cate_a"> <a  href = "/categories/技术杂谈/">技术杂谈</a>	</li>
				        	<li class = "article_cate_a"> <a href = "/categories/兴趣爱好/">兴趣爱好</a>		</li>
				        	<li class = "article_cate_a"> <a href = "/categories/日志/">日志</a></li>
				        	<li class = "article_cate_a"> <a href = "/categories/JavaScript/">JavaScript</a>	</li>
				        	<li class = "article_cate_a"> <a  href = "/categories/CSS3/">CSS3</a>	</li>
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/pfan123" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/gaolu1990/home?wvr=5" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>



				<style type="text/css">
					.article_cate_tit{
						color:#ba8f6c;
						margin-top:6px;
					}
					.article_cate_con a{
						display:block;
						font-size:12px;
						text-align:center;
						margin:4px 0;
					}
					#header .header-menu{
						line-height:21px;
					}
					.article_cate_a{
						line-height:18px !important;
					}	
					.article_cate_a a{
						font-size:12px !important;
					}				
					#container .left-col .overlay{
						height:130px;
					}
					.header-nav{
						top:160px;
					}
				</style>	
				<!-- E 新增模块-->
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/gitignore-git/" style="font-size: 10px;">.gitignore git</a> <a href="/tags/htaccess-配置二级域名-绑定子目录/" style="font-size: 10px;">.htaccess  配置二级域名  绑定子目录</a> <a href="/tags/AMD/" style="font-size: 10px;">AMD</a> <a href="/tags/CMD/" style="font-size: 10px;">CMD</a> <a href="/tags/CSS-BEM-OOCSS/" style="font-size: 10px;">CSS BEM OOCSS</a> <a href="/tags/CSS动画篇/" style="font-size: 10px;">CSS动画篇</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/ESLint/" style="font-size: 10px;">ESLint</a> <a href="/tags/Git，Git查看历史记录/" style="font-size: 10px;">Git，Git查看历史记录</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/H5-视频直播-video/" style="font-size: 10px;">H5 视频直播 video</a> <a href="/tags/H5全景、CSS3d、perspective/" style="font-size: 15px;">H5全景、CSS3d、perspective</a> <a href="/tags/HLS、RTMP协议/" style="font-size: 10px;">HLS、RTMP协议</a> <a href="/tags/HTML5/" style="font-size: 15px;">HTML5</a> <a href="/tags/HTML5-视频直播-video-canvas/" style="font-size: 10px;">HTML5 视频直播 video canvas</a> <a href="/tags/HTML5、localstorage、sessionStorage/" style="font-size: 10px;">HTML5、localstorage、sessionStorage</a> <a href="/tags/HTML、XML解析、dom-level、htmlparser2、xmldom、sax-js、cheerio/" style="font-size: 10px;">HTML、XML解析、dom level、htmlparser2、xmldom、sax-js、cheerio</a> <a href="/tags/HTTP、-node-http-proxy、-nginx、-proxy/" style="font-size: 15px;">HTTP、 node-http-proxy、 nginx、 proxy</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux、CentOS/" style="font-size: 10px;">Linux、CentOS</a> <a href="/tags/Linux、UNIX/" style="font-size: 10px;">Linux、UNIX</a> <a href="/tags/Linux、Unix/" style="font-size: 20px;">Linux、Unix</a> <a href="/tags/Linux、Unix、nvm、node/" style="font-size: 10px;">Linux、Unix、nvm、node</a> <a href="/tags/Mac-命令-Terminal-osx/" style="font-size: 10px;">Mac 命令 Terminal osx</a> <a href="/tags/Mac、root/" style="font-size: 10px;">Mac、root</a> <a href="/tags/Math-atan-、Math-atan2-斜率/" style="font-size: 10px;">Math.atan()、Math.atan2() 斜率</a> <a href="/tags/Mongoose参考手册-MongoDB-数据库-node/" style="font-size: 10px;">Mongoose参考手册  MongoDB  数据库 node</a> <a href="/tags/Nginx-负载均衡/" style="font-size: 10px;">Nginx  负载均衡</a> <a href="/tags/Nginx-负载均衡-node-jdc-解决方案-host/" style="font-size: 10px;">Nginx  负载均衡 node  jdc 解决方案 host</a> <a href="/tags/Nginx-Mac-Node/" style="font-size: 10px;">Nginx Mac Node</a> <a href="/tags/Nginx-MySQL-PHP-FPM-Mac-OS/" style="font-size: 10px;">Nginx MySQL PHP-FPM Mac OS</a> <a href="/tags/Nodejs学习实践-nodejs-ES6/" style="font-size: 10px;">Nodejs学习实践 nodejs  ES6</a> <a href="/tags/PreloadJS-EaselJS-TweenJS-SoundJS/" style="font-size: 10px;">PreloadJS EaselJS TweenJS SoundJS</a> <a href="/tags/SVG-Sprites-Symbols/" style="font-size: 10px;">SVG Sprites Symbols</a> <a href="/tags/SVG-icon、-导出优化/" style="font-size: 10px;">SVG icon、 导出优化</a> <a href="/tags/SVG、dataURI、base64/" style="font-size: 10px;">SVG、dataURI、base64</a> <a href="/tags/UMD/" style="font-size: 10px;">UMD</a> <a href="/tags/Vim-vi/" style="font-size: 10px;">Vim vi</a> <a href="/tags/Webhook，git/" style="font-size: 10px;">Webhook，git</a> <a href="/tags/Webhook，git，-Git-Hooks/" style="font-size: 10px;">Webhook，git， Git Hooks</a> <a href="/tags/createJS/" style="font-size: 10px;">createJS</a> <a href="/tags/css-modules-scope-模块化/" style="font-size: 10px;">css modules  scope  模块化</a> <a href="/tags/device-width-window-screen-width-区分ip6与ip6plus/" style="font-size: 10px;">device-width window.screen.width 区分ip6与ip6plus</a> <a href="/tags/deviceorientation、orientationchange-重力感应/" style="font-size: 10px;">deviceorientation、orientationchange 重力感应</a> <a href="/tags/deviceorientation、orientationchange-重力感应-CSS3D/" style="font-size: 10px;">deviceorientation、orientationchange 重力感应 CSS3D</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/fiddler/" style="font-size: 10px;">fiddler</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hexo初始/" style="font-size: 10px;">hexo初始</a> <a href="/tags/hexo相关问题/" style="font-size: 10px;">hexo相关问题</a> <a href="/tags/howler-js、-video-js/" style="font-size: 10px;">howler.js、 video.js</a> <a href="/tags/insertAdjacentHTML方法/" style="font-size: 10px;">insertAdjacentHTML方法</a> <a href="/tags/insertAdjacentText方法/" style="font-size: 10px;">insertAdjacentText方法</a> <a href="/tags/javascript、canvas、toDataURL/" style="font-size: 10px;">javascript、canvas、toDataURL()</a> <a href="/tags/letsencrypt、HTTPS、SSL、TSL/" style="font-size: 10px;">letsencrypt、HTTPS、SSL、TSL</a> <a href="/tags/mac-iphone-铃声/" style="font-size: 10px;">mac iphone 铃声</a> <a href="/tags/node-版本管理-nvm-n/" style="font-size: 10px;">node 版本管理  nvm  n</a> <a href="/tags/node-读写excel-JS-XLSX-分析excel写入/" style="font-size: 10px;">node 读写excel JS-XLSX 分析excel写入</a> <a href="/tags/pm2学习实践-nodejs-pm2/" style="font-size: 10px;">pm2学习实践 nodejs pm2</a> <a href="/tags/react-flux-redux-ECMAScript6-Vue-Angular-Angular2-0-NuclearJS/" style="font-size: 10px;">react flux redux ECMAScript6 Vue Angular Angular2.0 NuclearJS</a> <a href="/tags/ssh常用命令-SSH/" style="font-size: 10px;">ssh常用命令  SSH</a> <a href="/tags/svg、path、circle、rect、ellipse、polygon、polyline、line/" style="font-size: 10px;">svg、path、circle、rect、ellipse、polygon、polyline、line</a> <a href="/tags/video-canvas/" style="font-size: 10px;">video canvas</a> <a href="/tags/vue-router-vue/" style="font-size: 10px;">vue-router, vue</a> <a href="/tags/webp/" style="font-size: 10px;">webp</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/三角学、弧度、角度/" style="font-size: 10px;">三角学、弧度、角度</a> <a href="/tags/买房前必备知识-house-home/" style="font-size: 10px;">买房前必备知识  house home</a> <a href="/tags/买车前必备知识-car/" style="font-size: 10px;">买车前必备知识  car</a> <a href="/tags/京东购物H5活动CP重构规范/" style="font-size: 10px;">京东购物H5活动CP重构规范</a> <a href="/tags/优化JavaScript的执行效率/" style="font-size: 10px;">优化JavaScript的执行效率</a> <a href="/tags/前端性能优化/" style="font-size: 10px;">前端性能优化</a> <a href="/tags/吉他/" style="font-size: 10px;">吉他</a> <a href="/tags/吉他知识/" style="font-size: 10px;">吉他知识</a> <a href="/tags/学吉他知识集锦/" style="font-size: 10px;">学吉他知识集锦</a> <a href="/tags/搬瓦工，Shadowsocks/" style="font-size: 10px;">搬瓦工，Shadowsocks</a> <a href="/tags/旅游-帝都畅游-相约北京/" style="font-size: 10px;">旅游 帝都畅游 相约北京</a> <a href="/tags/模块的写法/" style="font-size: 10px;">模块的写法</a> <a href="/tags/运营规范/" style="font-size: 10px;">运营规范</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/pingfan1990/">博客园博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.w3cfuns.com/house.php">前端网博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://pingfan1990.sinaapp.com/">pfan展示平台</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://doc.pfan123.com/">pfan前端开发导航平台</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">因上努力，果上随缘</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">pfan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://litten.github.io/assets/blogImg/litten.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">pfan</h1>
			</hgroup>
			
			<p class="header-subtitle">新起点，新高度</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/pfan123" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/gaolu1990/home?wvr=5" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-如何在CentOS 6.x:7.x上安装git及最新版" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/03/如何在CentOS 6.x:7.x上安装git及最新版/" class="article-date">
  	<time datetime="2017-02-03T10:00:21.000Z" itemprop="datePublished">2017-02-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/03/如何在CentOS 6.x:7.x上安装git及最新版/">CentOS 6.x安装git及最新版</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="方式一、yum安装"><a href="#方式一、yum安装" class="headerlink" title="方式一、yum安装"></a>方式一、yum安装</h2><blockquote>
<p>通过yum方式安装，版本比较旧，CentOS6.5上安装好是1.7.1版。如果想安装最新版或其他版本，需要使用源码编译安装的方式。</p>
</blockquote>
<h2 id="方式二、源码包安装"><a href="#方式二、源码包安装" class="headerlink" title="方式二、源码包安装"></a>方式二、源码包安装</h2><p>步骤1. 安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span><br><span class="line">yum install  gcc perl-ExtUtils-MakeMaker  //控制make命令操作模块</span><br></pre></td></tr></table></figure>
<p>步骤2. 卸载旧的git版本（如果之前有安装rpm包）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove git</span><br></pre></td></tr></table></figure>
<p>步骤3. 下载&amp;解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget https://www.kernel.org/pub/software/scm/git/git-2.5.0.tar.gz</span><br><span class="line">tar -zxvf git-2.5.0.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或  wget <a href="http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.gz" target="_blank" rel="external">http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.gz</a> 下载 获取最新版本</p>
</blockquote>
<p>步骤4. 编译安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd git-2.5.0</span><br><span class="line">make prefix=/usr/local/git all</span><br><span class="line">make prefix=/usr/local/git install</span><br><span class="line">echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc</span><br><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure>
<p>步骤5. 检查git版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">git version 2.5.0</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="external">Make 命令教程</a></p>
<p><a href="http://www.runoob.com/linux/linux-yum.html" target="_blank" rel="external">linux yum 命令</a></p>
<p><a href="http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html" target="_blank" rel="external">linux yum命令详解</a></p>
<p><a href="https://blog.phpgao.com/vps_ssh.html" target="_blank" rel="external">VPS安全之SSH设置</a></p>
<p><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="external">Connecting to GitHub with SSH</a></p>
<p><a href="http://www.linmuxi.com/2016/02/24/github-config-ssh/" target="_blank" rel="external">Github之SSH连接配置</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux、CentOS/">Linux、CentOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-Linux与UNIX区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/03/Linux与UNIX区别/" class="article-date">
  	<time datetime="2017-02-03T03:00:21.000Z" itemprop="datePublished">2017-02-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/03/Linux与UNIX区别/">Linux 与 UNIX</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UNIX简介"><a href="#UNIX简介" class="headerlink" title="UNIX简介"></a>UNIX简介</h2><p>UNIX，一种计算机操作系统，具有多任务、多用户的特征。于1969年，在美国AT&amp;T公司的贝尔实验室开发类UNIX（UNIX-like）。</p>
<p>Unix的前身为1964年开始的Multics，贝尔实验室参与了这个操作系统的研发，但因为开发速度太慢，1969年贝尔实验室决定退出这个计划。贝尔实验室的工程师，肯·汤普逊和丹尼斯·里奇，在此时自行开发了Unix。</p>
<p>此后的10年，Unix在学术机构和大型企业中得到了广泛的应用，当时的UNIX拥有者AT&amp;T公司以低廉甚至免费的许可将Unix源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩充和改进，形成了所谓的“Unix变种”，这些变种反过来也促进了Unix的发展，其中最著名的变种之一是由加州大学柏克莱分校开发的柏克莱软件包(BSD)产品。</p>
<p>BSD使用主版本加次版本的方法标识，如4.2、4.3BSD，在原始版本的基础上还有派生版本，这些版本通常有自己的名字，如4.3BSD-Net/1，4.3BSD-Net/2等。BSD在发展中也逐渐派生出3个主要的分支：FreeBSD、OpenBSD和NetBSD。</p>
<p>详细资料：<a href="https://zh.wikipedia.org/wiki/UNIX" target="_blank" rel="external">UNIX</a></p>
<h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><p>Linux内核最初只是由芬兰人李纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。<br>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。<br>Linux能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h2 id="Linux的发行版"><a href="#Linux的发行版" class="headerlink" title="Linux的发行版"></a>Linux的发行版</h2><p>Linux的发行版说简单点就是将Linux内核与应用软件做一个打包。<br>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debain、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p>
<h2 id="Linux应用领域"><a href="#Linux应用领域" class="headerlink" title="Linux应用领域"></a>Linux应用领域</h2><p>今天各种场合都有使用各种Linux发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用LAMP（Linux + Apache + MySQL + PHP）或LNMP（Linux + Nginx+ MySQL + PHP）组合。<br>目前Linux不仅在家庭与企业中使用，并且在政府中也很受欢迎。</p>
<h2 id="Linux-vs-Window"><a href="#Linux-vs-Window" class="headerlink" title="Linux vs Window"></a>Linux vs Window</h2><p>目前国内Linux更多的是应用于服务器上，而桌面操作系统更多使用的是Window。主要区别如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">比较</th>
<th style="text-align:center">Windows</th>
<th style="text-align:center">Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">界面</td>
<td style="text-align:center">界面统一，外壳程序固定所有Windows程序菜单几乎一致，快捷键也几乎相同</td>
<td style="text-align:center">图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux的终端机是从UNIX传承下来，基本命令和操作方法也几乎一致。</td>
</tr>
<tr>
<td style="text-align:center">驱动程序</td>
<td style="text-align:center">驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的Windows下的驱动，也会比较头痛。</td>
<td style="text-align:center">由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td>
</tr>
<tr>
<td style="text-align:center">使用</td>
<td style="text-align:center">使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td>
<td style="text-align:center">图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td>
</tr>
<tr>
<td style="text-align:center">学习</td>
<td style="text-align:center">系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td>
<td style="text-align:center">系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td>
</tr>
<tr>
<td style="text-align:center">软件</td>
<td style="text-align:center">每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td>
<td style="text-align:center">大部分软件都可以自由获取，同样功能的软件选择较少。</td>
</tr>
</tbody>
</table>
<h2 id="linux-yum-命令"><a href="#linux-yum-命令" class="headerlink" title="linux yum 命令"></a>linux yum 命令</h2><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。<br>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。<br>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p>yum 语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure>
<ul>
<li>options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。</li>
<li>command：要进行的操作。</li>
<li>package操作的对象。</li>
</ul>
<h2 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h2><p>1.列出所有可更新的软件清单命令：yum check-update<br>2.更新所有软件命令：yum update<br>3.仅安装指定的软件命令：yum install <package_name><br>4.仅更新指定的软件命令：yum update <package_name><br>5.列出所有可安裝的软件清单命令：yum list<br>6.删除软件包命令：yum remove <package_name><br>7.查找软件包 命令：yum search <keyword><br>8.清除缓存命令:</keyword></package_name></package_name></package_name></p>
<ul>
<li>yum clean packages: 清除缓存目录下的软件包</li>
<li>yum clean headers: 清除缓存目录下的 headers</li>
<li>yum clean oldheaders: 清除缓存目录下旧的 headers</li>
<li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li>
</ul>
<p>参考资料：</p>
<p><a href="https://zh.wikipedia.org/wiki/UNIX" target="_blank" rel="external">UNIX</a></p>
<p><a href="https://zh.wikipedia.org/wiki/CentOS" target="_blank" rel="external">CentOS</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Ubuntu" target="_blank" rel="external">Ubuntu</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Debian" target="_blank" rel="external">Debian</a></p>
<p><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile" target="_blank" rel="external">跟我一起写Makefile</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux、UNIX/">Linux、UNIX</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-SVG 基本形状与路径" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/16/SVG 基本形状与路径/" class="article-date">
  	<time datetime="2017-01-16T01:10:21.000Z" itemprop="datePublished">2017-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/SVG 基本形状与路径/">聊聊 SVG 基本形状转换那些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间研究 SVG 压缩优化，发现SVG预定义的 <code>rect</code>、<code>circle</code>、<code>ellipse</code>、<code>line</code>、<code>polyline</code>、<code>polygon</code>  六种基本形状可通过path路径转换实现，这样可以在一定程度上减少代码量。不仅如此，我们常用的 SVG Path 动画(路径动画)，是以操作path中两个属性值<code>stroke-dasharray</code>和<code>stroke-dashoffset</code>来实现，基本形状转换为path路径，有利于实现路径动画。</p>
<h2 id="SVG基本形状"><a href="#SVG基本形状" class="headerlink" title="SVG基本形状"></a>SVG基本形状</h2><p>SVG 提供了<code>rect</code>、<code>circle</code>、<code>ellipse</code>、<code>line</code>、<code>polyline</code>、<code>polygon</code>六种基本形状用于图形绘制，这些形状可以直接用来绘制一些基本的形状，如矩形、椭圆等，而复杂图形的绘制则需要使用 path 路径来实现。</p>
<p><img src="http://img.pfan123.com/svgpath1.jpg" alt="svg基本形状"></p>
<h3 id="1-rect-矩形"><a href="#1-rect-矩形" class="headerlink" title="1.rect 矩形"></a>1.<code>rect</code> 矩形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;</span><br><span class="line">&lt;rect x=&quot;60&quot; y=&quot;10&quot; rx=&quot;10&quot; ry=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>SVG中<code>rect</code>元素用于绘制矩形、圆角矩形，含有6个基本属性用于控制矩形的形状以及坐标，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x       矩形左上角x位置, 默认值为 0 </span><br><span class="line">y       矩形左上角y位置, 默认值为 0</span><br><span class="line">width   矩形的宽度, 不能为负值否则报错, 0 值不绘制</span><br><span class="line">height  矩形的高度,  不能为负值否则报错, 0 值不绘制</span><br><span class="line">rx      圆角x方向半径, 不能为负值否则报错</span><br><span class="line">ry      圆角y方向半径, 不能为负值否则报错</span><br></pre></td></tr></table></figure>
<p>这里需要注意，<code>rx</code> 和 <code>ry</code> 的还有如下规则：</p>
<ul>
<li><code>rx</code> 和 <code>ry</code> 都没有设置, 则 rx = 0 ry = 0</li>
<li><code>rx</code> 和 <code>ry</code> 有一个值为0, 则相当于 rx = 0 ry = 0，圆角无效</li>
<li><code>rx</code> 和 <code>ry</code> 有一个被设置, 则全部取这个被设置的值</li>
<li><code>rx</code> 的最大值为 <code>width</code> 的一半, <code>ry</code> 的最大值为 <code>height</code> 的一半</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rx = rx || ry || 0;</span><br><span class="line">ry = ry || rx || 0;</span><br><span class="line"></span><br><span class="line">rx = rx &gt; width / 2 ? width / 2 : rx;</span><br><span class="line">ry = ry &gt; height / 2 ? height / 2 : ry;</span><br><span class="line"></span><br><span class="line">if(0 === rx || 0 === ry)&#123;</span><br><span class="line"> rx = 0,</span><br><span class="line"> ry = 0;  //圆角不生效，等同于，rx，ry都为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-circle-圆形"><a href="#2-circle-圆形" class="headerlink" title="2.circle 圆形"></a>2.<code>circle</code> 圆形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;#fff&quot;&gt;&lt;/circle&gt;</span><br></pre></td></tr></table></figure>
<p>SVG中<code>circle</code>元素用于绘制圆形，含有3个基本属性用于控制圆形的坐标以及半径，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r       半径</span><br><span class="line">cx      圆心x位置, 默认为 0</span><br><span class="line">cy      圆心y位置, 默认为 0</span><br></pre></td></tr></table></figure>
<h3 id="3-ellipse-椭圆"><a href="#3-ellipse-椭圆" class="headerlink" title="3.ellipse 椭圆"></a>3.<code>ellipse</code> 椭圆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ellipse cx=&quot;75&quot; cy=&quot;75&quot; rx=&quot;20&quot; ry=&quot;5&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>SVG中<code>ellipse</code>元素用于绘制椭圆，是<code>circle</code>元素更通用的形式，含有4个基本属性用于控制椭圆的形状以及坐标，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rx      椭圆x半径</span><br><span class="line">ry      椭圆y半径</span><br><span class="line">cx      圆心x位置, 默认为 0</span><br><span class="line">cy      圆心y位置, 默认为 0</span><br></pre></td></tr></table></figure>
<h3 id="4-line-直线"><a href="#4-line-直线" class="headerlink" title="4.line 直线"></a>4.<code>line</code> 直线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;line x1=&quot;10&quot; x2=&quot;50&quot; y1=&quot;110&quot; y2=&quot;150&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><code>Line</code>绘制直线。它取两个点的位置作为属性，指定这条线的起点和终点位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1 起点的x位置</span><br><span class="line">y1 起点的y位置</span><br><span class="line">x2 终点的x位置</span><br><span class="line">y2 终点的y位置</span><br></pre></td></tr></table></figure>
<h3 id="5-polyline-折线"><a href="#5-polyline-折线" class="headerlink" title="5.polyline 折线"></a>5.<code>polyline</code> 折线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;polyline points=&quot;60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><code>polyline</code>是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个points属性中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2”</span><br></pre></td></tr></table></figure>
<h3 id="6-polygon-多边形"><a href="#6-polygon-多边形" class="headerlink" title="6.polygon 多边形"></a>6.<code>polygon</code> 多边形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;polygon points=&quot;50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><code>polygon</code>和折线很像，它们都是由连接一组点集的直线构成。不同的是，<code>polygon</code>的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2， 路径绘制完闭合图形”</span><br></pre></td></tr></table></figure>
<h2 id="SVG-path-路径"><a href="#SVG-path-路径" class="headerlink" title="SVG path 路径"></a>SVG path 路径</h2><p>SVG 的路径<code>&lt;path&gt;</code>功能非常强大，它不仅能创建其他基本形状，还能创建更多复杂的形状。<code>&lt;path&gt;</code>路径是由一些命令来控制的，每一个命令对应一个字母，并且区分大小写，大写主要表示绝对定位，小写表示相对定位。<code>&lt;path&gt;</code> 通过属性 d 来定义路径， d 是一系列命令的集合，主要有以下几个命令：</p>
<p><img src="http://img.pfan123.com/svgpath2.jpg" alt="svg基本形状"></p>
<p>通常大部分形状，都可以通过指令<code>M(m)</code>、<code>L(l)</code>、<code>H(h)</code>、<code>V(v)</code>、<code>A(a)</code>来实现，注意特别要区分大小写，相对与绝对坐标情况，转换时推荐使用相对路径可减少代码量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以下两个等价</span><br><span class="line">d=&apos;M 10 10 20 20&apos;     // (10, 10) (20 20) 都是绝对坐标</span><br><span class="line">d=&apos;M 10 10 L 20 20&apos;</span><br><span class="line"></span><br><span class="line">// 以下两个等价</span><br><span class="line">d=&apos;m 10 10 20 20&apos;     // (10, 10) 绝对坐标, (20 20) 相对坐标</span><br><span class="line">d=&apos;M 10 10 l 20 20&apos;</span><br></pre></td></tr></table></figure>
<h2 id="SVG-基本形状路径转换原理"><a href="#SVG-基本形状路径转换原理" class="headerlink" title="SVG 基本形状路径转换原理"></a>SVG 基本形状路径转换原理</h2><h3 id="1-rect-to-path"><a href="#1-rect-to-path" class="headerlink" title="1.rect to path"></a>1.rect to path</h3><p>如下图所示，一个 <code>rect</code> 是由 4 个弧和 4 个线段构成；如果 <code>rect</code> 没有设置 rx 和 ry 则 <code>rect</code> 只是由 4 个线段构成。<code>rect</code> 转换为 <code>path</code> 只需要将 A ~ H 之间的弧和线段依次实现即可。</p>
<p><img src="http://img.pfan123.com/rect2path.png" alt="svg基本形状"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function rect2path(x, y, width, height, rx, ry) &#123;</span><br><span class="line">    /*</span><br><span class="line">    * rx 和 ry 的规则是：</span><br><span class="line">    * 1. 如果其中一个设置为 0 则圆角不生效</span><br><span class="line">    * 2. 如果有一个没有设置则取值为另一个</span><br><span class="line">    */</span><br><span class="line">    rx = rx || ry || 0;</span><br><span class="line">    ry = ry || rx || 0;</span><br><span class="line"></span><br><span class="line">   //非数值单位计算，如当宽度像100%则移除</span><br><span class="line">   if (isNaN(x - y + width - height + rx - ry)) return;</span><br><span class="line"></span><br><span class="line">   rx = rx &gt; width / 2 ? width / 2 : rx;</span><br><span class="line">   ry = ry &gt; height / 2 ? height / 2 : ry;</span><br><span class="line"></span><br><span class="line">   //如果其中一个设置为 0 则圆角不生效</span><br><span class="line">   if(0 == rx || 0 == ry)&#123;</span><br><span class="line">         // var path =</span><br><span class="line">         //     &apos;M&apos; + x + &apos; &apos; + y +</span><br><span class="line">         //     &apos;H&apos; + (x + width) +     不推荐用绝对路径，相对路径节省代码量</span><br><span class="line">         //     &apos;V&apos; + (y + height) +</span><br><span class="line">         //     &apos;H&apos; + x +</span><br><span class="line">         //     &apos;z&apos;;</span><br><span class="line">         var path =</span><br><span class="line">             &apos;M&apos; + x + &apos; &apos; + y +</span><br><span class="line">             &apos;h&apos; + width +</span><br><span class="line">             &apos;v&apos; + height +</span><br><span class="line">             &apos;h&apos; + -width +</span><br><span class="line">             &apos;z&apos;;                </span><br><span class="line">   &#125;else&#123;</span><br><span class="line">         var path =</span><br><span class="line">             &apos;M&apos; + x + &apos; &apos; + (y+ry) +</span><br><span class="line">             &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 0 1 &apos; + rx + &apos; &apos; + (-ry) + </span><br><span class="line">             &apos;h&apos; + (width - rx - rx) +</span><br><span class="line">             &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 0 1 &apos; + rx + &apos; &apos; + ry + </span><br><span class="line">             &apos;v&apos; + (height - ry -ry) +</span><br><span class="line">             &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 0 1 &apos; + (-rx) + &apos; &apos; + ry + </span><br><span class="line">             &apos;h&apos; + (rx + rx -width) +</span><br><span class="line">             &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 0 1 &apos; + (-rx) + &apos; &apos; + (-ry) + </span><br><span class="line">             &apos;z&apos;;        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-circle-ellipse-to-path"><a href="#2-circle-ellipse-to-path" class="headerlink" title="2.circle/ellipse to path"></a>2.circle/ellipse to path</h4><p>圆可视为是一种特殊的椭圆，即 rx 与 ry 相等的椭圆，所以可以放在一起讨论。 椭圆可以看成A点到C做180度顺时针画弧、C点到A做180度顺时针画弧即可。</p>
<p><img src="http://misc.aotu.io/pfan123/svgpath/ellipse2path.png" alt="svg基本形状"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ellipse2path(cx, cy, rx, ry) &#123;</span><br><span class="line">   //非数值单位计算，如当宽度像100%则移除</span><br><span class="line">   if (isNaN(cx - cy + rx - ry)) return;</span><br><span class="line"></span><br><span class="line">   var path =</span><br><span class="line">       &apos;M&apos; + (cx-rx) + &apos; &apos; + cy +</span><br><span class="line">       &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 1 0 &apos; + 2*rx + &apos; 0&apos; +</span><br><span class="line">       &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 1 0 &apos; + (-2*rx) + &apos; 0&apos; +</span><br><span class="line">       &apos;z&apos;; </span><br><span class="line"></span><br><span class="line">   return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-line-to-path"><a href="#3-line-to-path" class="headerlink" title="3.line to path"></a>3.line to path</h4><p>相对来说比较简单，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function line2path(x1, y1, x2, y2) &#123;</span><br><span class="line">   //非数值单位计算，如当宽度像100%则移除</span><br><span class="line">   if (isNaN(x1 - y1 + x2 - y2)) return; </span><br><span class="line">   </span><br><span class="line">    x1 = x1 || 0;</span><br><span class="line">    y1 = y1 || 0;</span><br><span class="line">    x2 = x2 || 0;</span><br><span class="line">    y2 = y2 || 0;</span><br><span class="line"></span><br><span class="line">    var path = &apos;M&apos; + x1 + &apos; &apos;+ y1 + &apos;L&apos; + x2 + &apos; &apos; + y2;</span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-polyline-polygon-to-path"><a href="#4-polyline-polygon-to-path" class="headerlink" title="4.polyline/polygon to path"></a>4.polyline/polygon to path</h3><p><code>polyline</code>折线、<code>polygon</code>多边形的转换为path比较类似，差别就是<code>polygon</code>多边形会闭合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// polygon折线转换</span><br><span class="line">points = [x1, y1, x2, y2, x3, y3 ...];</span><br><span class="line">function polyline2path (points) &#123;</span><br><span class="line">    var path = &apos;M&apos; + points.slice(0,2).join(&apos; &apos;) +</span><br><span class="line">                      &apos;L&apos; + points.slice(2).join(&apos; &apos;); </span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// polygon多边形转换</span><br><span class="line">points = [x1, y1, x2, y2, x3, y3 ...];</span><br><span class="line">function polygon2path (points) &#123;</span><br><span class="line">    var path = &apos;M&apos; + points.slice(0,2).join(&apos; &apos;) +</span><br><span class="line">                      &apos;L&apos; + points.slice(2).join(&apos; &apos;) + &apos;z&apos;; </span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="convertpath转换工具"><a href="#convertpath转换工具" class="headerlink" title="convertpath转换工具"></a><code>convertpath</code>转换工具</h3><p>为了方便处理SVG基本元素路径转换，本人抽空写了<a href="https://github.com/pfan123/convertpath" target="_blank" rel="external">convertpath</a>工具，具体如下：</p>
<p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i convertpath</span><br></pre></td></tr></table></figure></p>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const parse = require(&apos;convertpath&apos;);</span><br><span class="line">parse.parse(&quot;./test/test.svg&quot;)</span><br><span class="line">/**</span><br><span class="line"> * &lt;circle cx=&quot;500&quot; cy=&quot;500&quot; r=&quot;20&quot; fill=&quot;red&quot;/&gt;</span><br><span class="line"> */</span><br><span class="line">console.log(parse.toSimpleSvg())</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;path d=&quot;M500,500,m-20,0,a20,20,0,1,0,40,0,a20,20,0,1,0,-40,0,Z&quot; fill=&quot;red&quot;/&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="https://www.w3.org/TR/SVG/shapes.html" target="_blank" rel="external">Basic Shapes – SVG 1.1 (Second Edition)</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Basic_Shapes" target="_blank" rel="external">基本形状 - SVG | MDN</a><br><a href="https://segmentfault.com/a/1190000004393817" target="_blank" rel="external">SVG (一) 图形, 路径, 变换总结; 以及椭圆弧线, 贝塞尔曲线的详细解释</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths" target="_blank" rel="external">路径 - SVG | MDN</a><br><a href="https://github.com/jindw/xmldom" target="_blank" rel="external">XMLDOM</a>   </p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/svg、path、circle、rect、ellipse、polygon、polyline、line/">svg、path、circle、rect、ellipse、polygon、polyline、line</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-dataURI 中使用 SVG正确姿势" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/11/dataURI 中使用 SVG正确姿势/" class="article-date">
  	<time datetime="2017-01-11T03:00:21.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/dataURI 中使用 SVG正确姿势/">探究 dataURI 中使用 SVG 正确姿势</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了减少首页的请求数量，按照以往的思路，会直接将 SVG 转换为 base64 后插入了 CSS 文件中。代码可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.svg &#123;</span><br><span class="line">    background-image: url(&apos;data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjUwOCIgaGVpZ2h0PSIyNTIuNyIgdmlld0JveD0iMCAwIDI1MDggMjUyLjciPjxwb2x5Z29uIHBvaW50cz0iNCwyNTIuNyAyNTA0LDAgMjUwNCwyNTIuNyIgc3R5bGU9ImZpbGw6I2U2ZWJlYSIgLz48L3N2Zz4=&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初步开发完成后，为了进一步优化代码，在查询资料时读到了这篇文章：<a href="http://codepen.io/Tigt/post/optimizing-svgs-in-data-uris" target="_blank" rel="external">Optimizing SVGs in data URIs</a>。参考文章内容进行优化之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.svg &#123;</span><br><span class="line">    background-image: url(&quot;data:image/svg+xml;charset=utf8,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; version=&apos;1.1&apos;%3E%3Cpolygon points=&apos;4,252.7 2504,0 2504,252.7&apos; style=&apos;fill:%23e6ebea&apos;/%3E%3C/svg%3E&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比这两段代码，最明显的效果是代码量减少了一半多，而且代码非常清晰，几乎就是 SVG 代码原文，日后如果有一些细微的需求变更，比如更改填充色，可以直接在代码里修改无需进行编码转换。</p>
<h2 id="在-dataURI-中使用-SVG-的最佳方法-Optimizing-SVGs-in-data-URIs"><a href="#在-dataURI-中使用-SVG-的最佳方法-Optimizing-SVGs-in-data-URIs" class="headerlink" title="在 dataURI 中使用 SVG 的最佳方法 Optimizing SVGs in data URIs"></a>在 dataURI 中使用 SVG 的最佳方法 <a href="http://codepen.io/Tigt/post/optimizing-svgs-in-data-uris" target="_blank" rel="external">Optimizing SVGs in data URIs</a></h2><p>不久前，CSS-Tricks 发表了 <a href="https://css-tricks.com/probably-dont-base64-svg/" target="_blank" rel="external">“Probably Don’t Base64 SVG”</a>，得出结论：如果你在 data URI 中直接使用 SVG，数据量会比转化成 base64 编码格式时小。</p>
<p>这个观点是正确的，但是这里还有一些复杂的地方以及可优化的空间。</p>
<h2 id="更好的浏览器兼容性"><a href="#更好的浏览器兼容性" class="headerlink" title="更好的浏览器兼容性"></a>更好的浏览器兼容性</h2><p>例如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bg &#123;</span><br><span class="line">    background: url(&apos;data:image/svg+xml;utf8,&lt;svg ...&gt; ... &lt;/svg&gt;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在那些流行于 web 开发者中的浏览器中是有效的，但是在 IE 中则无法正常工作。因为从技术角度来说这是一种畸形的 data URI，而 IE 很严格（原文： This is because technically it’s a malformed data URI, and IE is being strict.）。</p>
<h3 id="RFC-2397-定义了-data-URI："><a href="#RFC-2397-定义了-data-URI：" class="headerlink" title="RFC 2397 定义了 data URI："></a><a href="http://www.ietf.org/rfc/rfc2397.txt" target="_blank" rel="external">RFC 2397</a> 定义了 data URI：</h3><blockquote>
<p>URL 的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;mediatype&gt;</code> 描述数据的 MIME 类型，<code>;base64</code> 的出现意味着数据被编码成 <code>base64</code> 格式。如果没有声明<code>;base64</code>，对于 URL 安全字符使用 ASCII 编码，而安全范围以外的字符则使用十六进制数编码为<code>%xx</code>格式。如果省略<code>&lt;mediatype&gt;</code>，默认为<code>text/plain;charset=US-ASCII</code>。</p>
</blockquote>
<p>换句话说，根据标准，只有如下两种编码 data URI 的方法是有效的：</p>
<ul>
<li>1.<code>data:mime/type;base64,[actual data]</code>：base64 编码，更适合于二进制数据（PNG，fonts，SVG 等等）</li>
<li>2.<code>data:mime/type;charset=[charset],[actual data]</code>：URL 编码的普通文本，更适合与文本标记语言（SVG，HTML等）</li>
</ul>
<p>所以，把一个 SVG 文件编码为 data URL 的正确方式为 <code>data:image/svg+xml;charset=utf8,[actual data]</code>。我猜大部分浏览器对是否存在<code>charset=</code>字符串比较宽容，但是在 IE 浏览器里是必须的。为了代码的最大兼容性（例如一些小众浏览器，邮件客户端，等等），它应该被包含在内。</p>
<p>但这并不是全部。记得这段话么？</p>
<blockquote>
<p>如果没有声明<code>;base64</code>，对于 URL 安全字符使用<code>ASCII</code> 编码，而安全范围以外的字符则使用十六进制数编码为<code>%xx</code>格式。如果省略<code>&lt;mediatype&gt;</code>，默认为<code>text/plain;charset=US-ASCII</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!-- Generated by IcoMoon.io --&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line">&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;512&quot; height=&quot;512&quot; viewBox=&quot;0 0 512 512&quot;&gt;&lt;g id=&quot;icomoon-ignore&quot;&gt;</span><br><span class="line">&lt;/g&gt;</span><br><span class="line">&lt;path d=&quot;M224 387.814v124.186l-192-192 192-192v126.912c223.375 5.24 213.794-151.896 156.931-254.912 140.355 151.707 110.55 394.785-156.931 387.814z&quot;&gt;&lt;/path&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>根据 Chris 的建议，我们使用 <a href="https://github.com/svg/svgo" target="_blank" rel="external">SVGO</a> 来优化我们的 SVG 文件（如果你更习惯图形界面，GUI 版本：<a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="external">SCGOMG</a>）。结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;512&quot; height=&quot;512&quot; viewBox=&quot;0 0 512 512&quot;&gt;&lt;path d=&quot;M224 387.814V512L32 320l192-192v126.912C447.375 260.152 437.794 103.016 380.93 0 521.287 151.707 491.48 394.785 224 387.814z&quot;/&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>文件小了很多！而且如果你打算用 CSS 来设定图像的尺寸，你还可以去掉<code>width</code>和<code>height</code>属性让代码更简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 512 512&quot;&gt;&lt;path d=&quot;M224 387.814V512L32 320l192-192v126.912C447.375 260.152 437.794 103.016 380.93 0 521.287 151.707 491.48 394.785 224 387.814z&quot;/&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>现在，我们把精简后的 SVG 丢进 <a href="http://meyerweb.com/eric/tools/dencoder/" target="_blank" rel="external">URL</a> 编码器，会得到这样的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20d%3D%22M224%20387.814V512L32%20320l192-192v126.912C447.375%20260.152%20437.794%20103.016%20380.93%200%20521.287%20151.707%20491.48%20394.785%20224%20387.814z%22%2F%3E%3C%2Fsvg%3E</span><br></pre></td></tr></table></figure>
<p>目前这是唯一能在 IE 中工作的版本。非常明显，这甚至比 base64 编码过后的 SVG 都要长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBkPSJNMjI0IDM4Ny44MTRWNTEyTDMyIDMyMGwxOTItMTkydjEyNi45MTJDNDQ3LjM3NSAyNjAuMTUyIDQzNy43OTQgMTAzLjAxNiAzODAuOTMgMCA1MjEuMjg3IDE1MS43MDcgNDkxLjQ4IDM5NC43ODUgMjI0IDM4Ny44MTR6Ii8</span><br></pre></td></tr></table></figure>
<h2 id="“引号是关键”"><a href="#“引号是关键”" class="headerlink" title="“引号是关键”"></a>“引号是关键”</h2><p>你可能注意到了，Chris 使用单引号（<code>&#39;</code>）来界定 data URIs。这是因为他的 SVG 文件未编码时使用双引号（<code>&quot;</code>）来包裹属性值，为了避免冲突而使用了单引号来代替。这一点点微小的改变其实是真正精简 data URI 的关键。</p>
<p><code>&quot;</code> 和 <code>&#39;</code> 都是有效的属性分隔符（即：<code>attribute=&quot;value&quot;</code> 和 <code>attribute=&#39;value&#39;</code> 都有效），但是只有<code>&#39;</code>可以直接在 URL 中使用而无须编码转换。现在我们替换双引号，编码<code>&lt;</code>和<code>&gt;</code>，得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 512 512&apos;%3E%3Cpath d=&apos;M224 387.814V512L32 320l192-192v126.912C447.375 260.152 437.794 103.016 380.93 0 521.287 151.707 491.48 394.785 224 387.814z&apos;/%3E%3C/svg%3E</span><br></pre></td></tr></table></figure>
<p>所以，当你把 SVG 作为 data URI使用时：</p>
<p>用单引号替换包裹属性值的双引号<br>编码 <code>&lt;</code>，<code>&gt;</code>，<code>#</code>，和剩余的 <code>&quot;</code> （例如在文本内容中的双引号），以及其他一直的不安全 URL 字符（例如 <code>%</code>）<br>使用双引号来分隔 data URI（<code>&lt;img src=&quot;&quot;&gt;</code>，<code>url(&quot;&quot;)</code>）</p>
<p>网友 jakob-e 在 SASS 中实现了这个算法，使整个流程变得非常简单：</p>
<iframe scrolling="no" src="//codepen.io/jakob-e/embed/doMoML/?height=287&amp;theme-id=0&amp;default-tab=js" allowtransparency="true" allowfullscreen="true" style="width: 100%;" frameborder="no" height="287">See the Pen &lt;a href=’<a href="http://codepen.io/jakob-e/pen/doMoML/&#39;&gt;Encode" target="_blank" rel="external">http://codepen.io/jakob-e/pen/doMoML/&#39;&gt;Encode</a> SVG SCSS&lt;/a&gt; by jakob-e (&lt;a href=’<a href="http://codepen.io/jakob-e&#39;&gt;@jakob-e&lt;/a&amp;gt" target="_blank" rel="external">http://codepen.io/jakob-e&#39;&gt;@jakob-e&lt;/a&amp;gt</a>;) on &lt;a href=’<a href="http://codepen.io&#39;&gt;CodePen&lt;/a&amp;gt" target="_blank" rel="external">http://codepen.io&#39;&gt;CodePen&lt;/a&amp;gt</a>;.<br></iframe>

<p>以上就是如何得到能够在 IE （以及标准）中使用最精简的 data URI。总结一下：</p>
<p>base64 编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBkPSJNMjI0IDM4Ny44MTRWNTEyTDMyIDMyMGwxOTItMTkydjEyNi45MTJDNDQ3LjM3NSAyNjAuMTUyIDQzNy43OTQgMTAzLjAxNiAzODAuOTMgMCA1MjEuMjg3IDE1MS43MDcgNDkxLjQ4IDM5NC43ODUgMjI0IDM4Ny44MTR6Ii8+PC9zdmc+</span><br></pre></td></tr></table></figure>
<p>完全 URL 编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/svg+xml;charset=utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20d%3D%22M224%20387.814V512L32%20320l192-192v126.912C447.375%20260.152%20437.794%20103.016%20380.93%200%20521.287%20151.707%20491.48%20394.785%20224%20387.814z%22%2F%3E%3C%2Fsvg%3E</span><br></pre></td></tr></table></figure>
<p>最大程度优化的 URL 编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/svg+xml;charset=utf8,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 512 512&apos;%3E%3Cpath d=&apos;M224%20387.814V512L32 320l192-192v126.912C447.375 260.152 437.794 103.016 380.93 0 521.287 151.707 491.48 394.785 224 387.814z&apos;/%3E%3C/svg%3E</span><br></pre></td></tr></table></figure></p>
<p>我们测试发现，结果它在 IE9+ 以及 安卓3.x 以上的浏览器中都能够完美显示。</p>
<iframe scrolling="no" src="//codepen.io/Tigt/embed/wavYWE/?height=268&amp;theme-id=0&amp;default-tab=result" allowtransparency="true" allowfullscreen="true" style="width: 100%;" frameborder="no" height="268">See the Pen &lt;a href=’<a href="http://codepen.io/Tigt/pen/wavYWE/&#39;&gt;Cross-Browser" target="_blank" rel="external">http://codepen.io/Tigt/pen/wavYWE/&#39;&gt;Cross-Browser</a> data URI encoding test&lt;/a&gt; by Taylor Hunt (&lt;a href=’<a href="http://codepen.io/Tigt&#39;&gt;@Tigt&lt;/a&amp;gt" target="_blank" rel="external">http://codepen.io/Tigt&#39;&gt;@Tigt&lt;/a&amp;gt</a>;) on &lt;a href=’<a href="http://codepen.io&#39;&gt;CodePen&lt;/a&amp;gt" target="_blank" rel="external">http://codepen.io&#39;&gt;CodePen&lt;/a&amp;gt</a>;.<br></iframe>

<p>参考资料：</p>
<p><a href="http://codepen.io/Tigt/post/optimizing-svgs-in-data-uris" target="_blank" rel="external">Optimizing SVGs in data URIs</a></p>
<p><a href="https://css-tricks.com/probably-dont-base64-svg/" target="_blank" rel="external">Probably Don’t Base64 SVG</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SVG、dataURI、base64/">SVG、dataURI、base64</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-localstorage基本知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/15/localstorage基本知识/" class="article-date">
  	<time datetime="2016-12-15T08:56:21.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/localstorage基本知识/">localstorage基本知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTML5-LocalStorage-发展历程"><a href="#HTML5-LocalStorage-发展历程" class="headerlink" title="HTML5 LocalStorage 发展历程"></a>HTML5 LocalStorage 发展历程</h2><p>说到本地存储，这玩意真是历尽千辛万苦才走到HTML5这一步，之前的历史大概如下图所示：</p>
<p><img src="//img.pfan123.com/localstorage_1.jpg" alt="HTML5 LocalStorage发展历史"></p>
<p>最早的Cookies自然是大家都知道，问题主要就是太小，大概也就4KB的样子，而且IE6只支持每个域名20个cookies，太少了。优势就是大家都支持，而且支持得还蛮好。很早以前那些禁用cookies的用户也都慢慢的不存在了，就好像以前禁用javascript的用户不存在了一样。</p>
<p>到了HTML5把这些都统一了，官方建议是每个网站5MB，非常大了，就存些字符串，足够了。比较诡异的是居然所有支持的浏览器目前都采用的5MB，尽管有一些浏览器可以让用户设置，但对于网页制作者来说，目前的形势就5MB来考虑是比较妥当的。 </p>
<h2 id="HTML-本地存储API"><a href="#HTML-本地存储API" class="headerlink" title="HTML 本地存储API"></a>HTML 本地存储API</h2><p>localstorage在浏览器的API有两个：<code>localStorage</code>和<code>sessionStorage</code>，存在于window对象中：<code>localStorage</code>对应<code>window.localStorage</code>，<code>sessionStorage</code>对应<code>window.sessionStorage</code>。<br><code>localStorage</code>和<code>sessionStorage</code>的区别主要是在于其生存期。</p>
<h2 id="本地存储基本使用方法"><a href="#本地存储基本使用方法" class="headerlink" title="本地存储基本使用方法"></a>本地存储基本使用方法</h2><p>localStorage用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&quot;b&quot;,&quot;isaac&quot;);//设置b为&quot;isaac&quot;</span><br><span class="line">var b = localStorage.getItem(&quot;b&quot;);//获取b的值,为&quot;isaac&quot;</span><br><span class="line">var a = localStorage.key(0); // 获取第0个数据项的键名，此处即为“b”</span><br><span class="line">localStorage.removeItem(&quot;b&quot;);//清除c的值</span><br><span class="line">localStorage.clear();//清除当前域名下的所有localstorage数据</span><br></pre></td></tr></table></figure></p>
<p>sessionStorage用法（在当前页面才能生效，反之清楚存储）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(&quot;b&quot;,&quot;isaac&quot;);//设置b为&quot;isaac&quot;</span><br><span class="line">var b = sessionStorage.getItem(&quot;b&quot;);//获取b的值,为&quot;isaac&quot;</span><br><span class="line">var a = sessionStorage.key(0); // 获取第0个数据项的键名，此处即为“b”</span><br><span class="line">sessionStorage.removeItem(&quot;b&quot;);//清除c的值</span><br><span class="line">sessionStorage.clear();//清除当前域名下的所有localstorage数据</span><br></pre></td></tr></table></figure>
<h2 id="本地存储作用域"><a href="#本地存储作用域" class="headerlink" title="本地存储作用域"></a>本地存储作用域</h2><p><img src="//img.pfan123.com/localstorage_2.png" alt="HTML5 LocalStorage发展历史"></p>
<ul>
<li>这里的作用域指的是：如何隔离开不同页面之间的<code>localStorage</code>（总不能在百度的页面上能读到腾讯的<code>localStorage</code>吧，哈哈哈）。</li>
<li><code>localStorage</code>只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份<code>localStorage</code>数据。</li>
<li><code>sessionStorage</code>比<code>localStorage</code>更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。</li>
</ul>
<h2 id="本地存储生存期"><a href="#本地存储生存期" class="headerlink" title="本地存储生存期"></a>本地存储生存期</h2><p><code>localStorage</code>理论上来说是永久有效的，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。但需要注意的是，在移动设备上的浏览器或各<code>Native App</code>用到的<code>WebView</code>里，<code>localStorage</code>都是不可靠的，可能会因为各种原因（比如说退出App、网络切换、内存不足等原因）被清空。<br><code>sessionStorage</code>的生存期顾名思义，类似于<code>session</code>，只要关闭浏览器（也包括浏览器的标签页），就会被清空。由于<code>sessionStorage</code>的生存期太短，因此应用场景很有限，但从另一方面来看，不容易出现异常情况，比较可靠。</p>
<h2 id="本地存储的空间（SIZE）"><a href="#本地存储的空间（SIZE）" class="headerlink" title="本地存储的空间（SIZE）"></a>本地存储的空间（SIZE）</h2><p>各主流浏览器（包含PC、移动端）竟然惊人的一致，pc端为5M，移动的为2.5M。值得说明的是，安卓上手 Q 、手机QQ浏览器、微信中则是 2.5M 的数量级，因此在移动端，本地存储的 SIZE 更加珍贵。IOS 待测试。 综上，SIZE 在 2 - 5M 的区间。 测试页面：<a href="http://dev-test.nemikor.com/web-storage/support-test/" target="_blank" rel="external">Web Storage Support Test
</a></p>
<h3 id="超过最大值的行为"><a href="#超过最大值的行为" class="headerlink" title="超过最大值的行为"></a>超过最大值的行为</h3><ul>
<li>各浏览器也惊人的一致，都是抛出一个错误<code>QUOTA_EXCEEDED_ERR</code>。</li>
<li>在<code>firefox</code>以及<code>opera</code>中，用户可以自己设置本地存储的大小。</li>
</ul>
<p><img src="//img.pfan123.com/localstorage_3.png" alt="HTML5 LocalStorage发展历史"></p>
<h2 id="整站本地存储的规划"><a href="#整站本地存储的规划" class="headerlink" title="整站本地存储的规划"></a>整站本地存储的规划</h2><p>客户端的存储空间非常宝贵，然而站点也因为业务的不同，很难有一个统一的实施细则，但是有几个大原则不会变。</p>
<ul>
<li>只保存重要页面的重要数据<br>典型的，首页首屏<br>对业务庞大的站点，这点尤其重要</li>
<li>极大提高用户体验的数据<br>比如表单的状态，可以提交之前保存，当用户刷新页面时可以还原<br>静态资源，比如 js 和 css</li>
<li>一个请求一个 key 值（一个 cgi 一个 key 值）<br>避免请求链接加参数的 key (<a href="http://request-ajax.cgi[params])，这样必然让" target="_blank" rel="external">http://request-ajax.cgi[params])，这样必然让</a> key 值趋于冗余从而撑爆空间<br>以上几大原则仅作参考，一切从实际业务出发。</li>
</ul>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/xiaowei0705/archive/2011/04/19/2021372.html" target="_blank" rel="external">HTML5 LocalStorage 本地存储</a></p>
<p><a href="https://segmentfault.com/a/1190000004121465" target="_blank" rel="external">localstorage 必知必会</a></p>
<p><a href="http://imweb.io/topic/5590a443fbb23aae3d5e450a" target="_blank" rel="external">使用localStorage必须了解的点</a>  </p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML5、localstorage、sessionStorage/">HTML5、localstorage、sessionStorage</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-解析HTML:XML生成文档对象模型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/08/解析HTML:XML生成文档对象模型/" class="article-date">
  	<time datetime="2016-12-08T08:56:21.000Z" itemprop="datePublished">2016-12-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/08/解析HTML:XML生成文档对象模型/">解析HTML/XML生成文档对象模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间研究svg压缩处理优化，针对文本html、xml文件解析成DOM文档对象，一直困扰着我。那么，今天讲讲借助<a href="https://github.com/fb55/htmlparser2" target="_blank" rel="external">htmlparser2</a>、<a href="https://github.com/isaacs/sax-js" target="_blank" rel="external">sax-js</a>、<a href="https://github.com/jindw/xmldom" target="_blank" rel="external">xmldom</a> 解析HTML/XML。</p>
<h2 id="htmlparser2"><a href="#htmlparser2" class="headerlink" title="htmlparser2"></a>htmlparser2</h2><p>htmlparser2可以用来处理HTML / XML / RSS的解析器，可以接收流文件，并提供回调接口。<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">cheerio</a>底层就是用此原理。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p><a href="http://demos.forbeslindesay.co.uk/htmlparser2/" target="_blank" rel="external">htmlparser2线上解析演示</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install htmlparser2</span><br></pre></td></tr></table></figure>
<h3 id="使用todo"><a href="#使用todo" class="headerlink" title="使用todo"></a>使用todo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//解析</span><br><span class="line">var htmlparser = require(&quot;htmlparser2&quot;);</span><br><span class="line">var parser = new htmlparser.Parser(&#123;</span><br><span class="line">    onopentag: function(name, attribs)&#123;</span><br><span class="line">        if(name === &quot;script&quot; &amp;&amp; attribs.type === &quot;text/javascript&quot;)&#123;</span><br><span class="line">            console.log(&quot;JS! Hooray!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ontext: function(text)&#123;</span><br><span class="line">        console.log(&quot;--&gt;&quot;, text);</span><br><span class="line">    &#125;,</span><br><span class="line">    onclosetag: function(tagname)&#123;</span><br><span class="line">        if(tagname === &quot;script&quot;)&#123;</span><br><span class="line">            console.log(&quot;That&apos;s it?!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;decodeEntities: true&#125;);</span><br><span class="line">parser.write(&quot;Xyz &lt;script type=&apos;text/javascript&apos;&gt;var foo = &apos;&lt;&lt;bar&gt;&gt;&apos;;&lt;/ script&gt;&quot;);</span><br><span class="line">parser.end();</span><br><span class="line"></span><br><span class="line">//生成简单的文档对象</span><br><span class="line">var htmlparser = require(&quot;htmlparser2&quot;);</span><br><span class="line">var rawHtml = &quot;Xyz &lt;script language= javascript&gt;var foo = &apos;&lt;&lt;bar&gt;&gt;&apos;;&lt; /  script&gt;&lt;!--&lt;!-- Waah! -- --&gt;&quot;;</span><br><span class="line">var handler = new htmlparser.DomHandler(function (error, dom) &#123;</span><br><span class="line">    if (error)&#123;</span><br><span class="line">    	throw new error()</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    	console.log(dom);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;);</span><br><span class="line">var parser = new htmlparser.Parser(handler);</span><br><span class="line">parser.write(rawHtml);</span><br><span class="line">parser.done();</span><br></pre></td></tr></table></figure>
<h3 id="htmlparser2监听事件Events"><a href="#htmlparser2监听事件Events" class="headerlink" title="htmlparser2监听事件Events"></a>htmlparser2监听事件Events</h3><p>监听处理键值对象函数，仅对有效的键值进行处理，否则中断。</p>
<ul>
<li>onopentag(<str> name, <obj> attributes)  </obj></str></li>
<li>onopentagname(<str> name)</str></li>
<li>onattribute(<str> name, <str> value)</str></str></li>
<li>ontext(<str> text)</str></li>
<li>onclosetag(<str> name)</str></li>
<li>onprocessinginstruction(<str> name, <str> data)</str></str></li>
<li>oncomment(<str> data)</str></li>
<li>oncommentend()</li>
<li>oncdatastart()</li>
<li>oncdataend()</li>
<li>onerror(<err> error)</err></li>
<li>onreset()</li>
<li>onend()</li>
</ul>
<h3 id="htmlparser2解析方法"><a href="#htmlparser2解析方法" class="headerlink" title="htmlparser2解析方法"></a>htmlparser2解析方法</h3><ul>
<li>write (别名: parseChunk)</li>
</ul>
<p>解析数据块，触发相应的回调函数</p>
<ul>
<li>end (别名: done)</li>
</ul>
<p>解析buffer数据和清除堆栈结束，触发 onend 回调函数。</p>
<ul>
<li>reset</li>
</ul>
<p>重置buffer以及stack，触发 onreset 函数</p>
<ul>
<li>parseComplete</li>
</ul>
<p>重置解析器解析数据，触发调用 end。</p>
<h3 id="htmlparser2参数-Option"><a href="#htmlparser2参数-Option" class="headerlink" title="htmlparser2参数 Option"></a>htmlparser2参数 Option</h3><ul>
<li>Option: xmlMode</li>
</ul>
<p>表示是否是特殊标签<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>应该得到特殊处理, 如果是空”empty” 的标签（如&lt; br &gt;）含有子元素。如果没有特殊处理，则特殊标签将做文本处理。<br>解析其它XML内容(不包含HTML文件), 设置为true。默认值:false。</p>
<ul>
<li>Option: decodeEntities</li>
</ul>
<p>设置为true，文档中内容实体部分将解码。默认值为false。</p>
<ul>
<li>Option: lowerCaseTags</li>
</ul>
<p>设置为true，所有标签将小写展示。xmlMode不设置情况下，默认值为true。</p>
<ul>
<li>Option: lowerCaseAttributeNames</li>
</ul>
<p>设置为true，所以属性name将设置为小写。由于影响解析速度，默认值为false。</p>
<ul>
<li>Option: recognizeCDATA</li>
</ul>
<p>设置为true，CDATA区域将被认为文本，即使xmlMode选项不启用。注意，xmlMode被设置为true,那么CDATA节总是会被认为是文本。</p>
<ul>
<li>Option: recognizeSelfClosing</li>
</ul>
<p>设置为true，其关闭标签将触发 onclosetag 事件即使xmlMode没有设置为true。注意: xmlMode设置为true,那么自闭标签总是被认可。</p>
<blockquote>
<p>htmlparser2主要是提供了对HTML / XML / RSS的解析，效率比较高，而相应生成简单的文档对象，需要借助<a href="https://github.com/fb55/domhandler" target="_blank" rel="external">domhandler</a>模块，只是增加了DOM level 1不便于操作。</p>
</blockquote>
<h2 id="sax-js"><a href="#sax-js" class="headerlink" title="sax-js"></a>sax-js</h2><p>sax-style风格处理XML和HTML的解析器，<a href="https://github.com/isaacs/sax-js" target="_blank" rel="external">sax js</a>。</p>
<h3 id="安装使用-1"><a href="#安装使用-1" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sax-js</span><br></pre></td></tr></table></figure>
<h3 id="使用todo-1"><a href="#使用todo-1" class="headerlink" title="使用todo"></a>使用todo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var sax = require(&quot;./lib/sax&quot;),</span><br><span class="line">  strict = true, // set to false for html-mode</span><br><span class="line">  parser = sax.parser(strict);</span><br><span class="line"></span><br><span class="line">parser.onerror = function (e) &#123;</span><br><span class="line">  // an error happened.</span><br><span class="line">&#125;;</span><br><span class="line">parser.ontext = function (t) &#123;</span><br><span class="line">  // got some text.  t is the string of text.</span><br><span class="line">&#125;;</span><br><span class="line">parser.onopentag = function (node) &#123;</span><br><span class="line">  // opened a tag.  node has &quot;name&quot; and &quot;attributes&quot;</span><br><span class="line">&#125;;</span><br><span class="line">parser.onattribute = function (attr) &#123;</span><br><span class="line">  // an attribute.  attr has &quot;name&quot; and &quot;value&quot;</span><br><span class="line">&#125;;</span><br><span class="line">parser.onend = function () &#123;</span><br><span class="line">  // parser stream is done, and ready to have more stuff written to it.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parser.write(&apos;&lt;xml&gt;Hello, &lt;who name=&quot;world&quot;&gt;world&lt;/who&gt;!&lt;/xml&gt;&apos;).close();</span><br><span class="line"></span><br><span class="line">// stream usage</span><br><span class="line">// takes the same options as the parser</span><br><span class="line">var saxStream = require(&quot;sax&quot;).createStream(strict, options)</span><br><span class="line">saxStream.on(&quot;error&quot;, function (e) &#123;</span><br><span class="line">  // unhandled errors will throw, since this is a proper node</span><br><span class="line">  // event emitter.</span><br><span class="line">  console.error(&quot;error!&quot;, e)</span><br><span class="line">  // clear the error</span><br><span class="line">  this._parser.error = null</span><br><span class="line">  this._parser.resume()</span><br><span class="line">&#125;)</span><br><span class="line">saxStream.on(&quot;opentag&quot;, function (node) &#123;</span><br><span class="line">  // same object as above</span><br><span class="line">&#125;)</span><br><span class="line">// pipe is supported, and it&apos;s readable/writable</span><br><span class="line">// same chunks coming in also go out.</span><br><span class="line">fs.createReadStream(&quot;file.xml&quot;)</span><br><span class="line">  .pipe(saxStream)</span><br><span class="line">  .pipe(fs.createWriteStream(&quot;file-copy.xml&quot;))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于sax-js解析的许多方法基本与htmlparser2一致，只是解析效率上比htmlparser2稍差。</p>
</blockquote>
<h2 id="XMLDOM"><a href="#XMLDOM" class="headerlink" title="XMLDOM"></a>XMLDOM</h2><p><a href="https://github.com/jindw/xmldom" target="_blank" rel="external">XMLDOM</a>是一款非常强大的解析工具，可实现浏览使用的 javascript文档对象模型 (W3C DOM) 。完美兼容DOM Level 2 以及部分 DOM Level 3。支持支持DOMParser和XMLSerializer接口浏览。解析为文档对象</p>
<p>参考资料:<br><a href="http://www.w3cplus.com/svg/svg-tips-for-designers.html" target="_blank" rel="external">创建和导出SVG的技巧</a><br><a href="https://ashung.github.io/stories/svg-export.html" target="_blank" rel="external">SVG 导出与优化</a></p>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p>npm install xmldom</p>
<h3 id="使用todo-2"><a href="#使用todo-2" class="headerlink" title="使用todo"></a>使用todo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var DOMParser = require(&apos;xmldom&apos;).DOMParser;</span><br><span class="line">var doc = new DOMParser().parseFromString(</span><br><span class="line">    &apos;&lt;xml xmlns=&quot;a&quot; xmlns:c=&quot;./lite&quot;&gt;\n&apos;+</span><br><span class="line">        &apos;\t&lt;child&gt;test&lt;/child&gt;\n&apos;+</span><br><span class="line">        &apos;\t&lt;child&gt;&lt;/child&gt;\n&apos;+</span><br><span class="line">        &apos;\t&lt;child/&gt;\n&apos;+</span><br><span class="line">    &apos;&lt;/xml&gt;&apos;</span><br><span class="line">    ,&apos;text/xml&apos;);</span><br><span class="line">//doc相当于document，doc.documentElement相当于document.documentElement</span><br><span class="line">doc.documentElement.setAttribute(&apos;x&apos;,&apos;y&apos;);</span><br><span class="line">doc.documentElement.setAttributeNS(&apos;./lite&apos;,&apos;c:x&apos;,&apos;y2&apos;);</span><br><span class="line">var nsAttr = doc.documentElement.getAttributeNS(&apos;./lite&apos;,&apos;x&apos;)</span><br><span class="line">console.info(nsAttr)</span><br><span class="line">console.info(doc)</span><br></pre></td></tr></table></figure>
<h3 id="API特征"><a href="#API特征" class="headerlink" title="API特征"></a>API特征</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMParser" target="_blank" rel="external">DOMParser</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFromString(xmlsource,mimeType)</span><br></pre></td></tr></table></figure>
<p>options extension by xmldom(not BOM standard!!)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//added the options argument</span><br><span class="line">new DOMParser(options)</span><br><span class="line"></span><br><span class="line">//errorHandler is supported</span><br><span class="line">new DOMParser(&#123;</span><br><span class="line">    /**</span><br><span class="line">     * locator is always need for error position info</span><br><span class="line">     */</span><br><span class="line">    locator:&#123;&#125;,</span><br><span class="line">    /**</span><br><span class="line">     * you can override the errorHandler for xml parser</span><br><span class="line">     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html</span><br><span class="line">     */</span><br><span class="line">    errorHandler:&#123;warning:function(w)&#123;console.warn(w)&#125;,error:callback,fatalError:callback&#125;</span><br><span class="line">    //only callback model</span><br><span class="line">    //errorHandler:function(level,msg)&#123;console.log(level,msg)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer" target="_blank" rel="external">XMLSerializer 可以将DOM subtree 和 DOM document转换为文本</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializeToString(node)</span><br></pre></td></tr></table></figure>
<h3 id="DOM-level2-方法-method-和-属性-attribute"><a href="#DOM-level2-方法-method-和-属性-attribute" class="headerlink" title="DOM level2 方法(method) 和 属性(attribute):"></a>DOM level2 方法(method) 和 属性(attribute):</h3><ul>
<li><a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247" target="_blank" rel="external">Node</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">attribute:</span><br><span class="line">    nodeValue|prefix</span><br><span class="line">readonly attribute:</span><br><span class="line">    nodeName|nodeType|parentNode|childNodes|firstChild|lastChild|previousSibling|nextSibling|attributes|ownerDocument|namespaceURI|localName</span><br><span class="line">method: </span><br><span class="line">    insertBefore(newChild, refChild)</span><br><span class="line">    replaceChild(newChild, oldChild)</span><br><span class="line">    removeChild(oldChild)</span><br><span class="line">    appendChild(newChild)</span><br><span class="line">    hasChildNodes()</span><br><span class="line">    cloneNode(deep)</span><br><span class="line">    normalize()</span><br><span class="line">    isSupported(feature, version)</span><br><span class="line">    hasAttributes()</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-102161490" target="_blank" rel="external">DOMImplementation</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method:</span><br><span class="line">    hasFeature(feature, version)</span><br><span class="line">    createDocumentType(qualifiedName, publicId, systemId)</span><br><span class="line">    createDocument(namespaceURI, qualifiedName, doctype)</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="https://github.com/fb55/domhandler" target="_blank" rel="external">domhandler</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMParser" target="_blank" rel="external">DOMParser</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer" target="_blank" rel="external">XMLSerializer 可以将DOM subtree 和 DOM document转换为文本</a>  </p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML、XML解析、dom-level、htmlparser2、xmldom、sax-js、cheerio/">HTML、XML解析、dom level、htmlparser2、xmldom、sax-js、cheerio</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-SVG 导出与优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/03/SVG 导出与优化/" class="article-date">
  	<time datetime="2016-12-03T08:56:21.000Z" itemprop="datePublished">2016-12-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/03/SVG 导出与优化/">SVG 导出与优化（转载）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="使用-Illustrator-导出-SVG"><a href="#使用-Illustrator-导出-SVG" class="headerlink" title="使用 Illustrator 导出 SVG"></a>使用 Illustrator 导出 SVG</h2><p>Illustrator 是目前相对较好的 SVG 设计工具，在 Illustrator 中另存为 SVG 是较常用的导出 SVG 方法，具体如何操作网上有很多资料。如果你熟悉 Illustrator 或者决定使用 Illustrator 绘制图标，你可以从查看官方帮助文档<a href="https://helpx.adobe.com/cn/illustrator/using/saving-artwork.html" target="_blank" rel="external">存储图稿-以 SVG 格式存储</a>，或者 <a href="http://create.adobe.com/2015/11/9/inspire_is_now_adobe_create_magazine.html" target="_blank" rel="external">Exporting SVG for the web with Adobe Illustrator CC</a>。也可以看看 <a href="https://sarasoueidan.com/" target="_blank" rel="external">Sara Soueidan</a> 在她的文章 <a href="https://sarasoueidan.com/blog/svg-tips-for-designers/" target="_blank" rel="external">Tips for Creating and Exporting Better SVGs for the Web</a> 中介绍的一些 Illustrator 关于创建和导出 SVG 的技巧。</p>
<p>另外在 Illustrator 上直接复制选中内容，粘贴至文本编辑器，也可以得到选中内容的 SVG 代码。我在做网页用的 SVG 时就经常这么做，画个矩形作为图标的边界，把图标连同矩形一起复制，然后在粘贴到文本编辑器里，再删除矩形的代码。但这对设计师来说较复杂了，也不适合批量操作，此外这种方法无法控制路径数据的精度。</p>
<p>还有一种方法是使用 Illustrator 画板导出 SVG，画板大小做为图标切图区域，在另存为 SVG 时选择导出多个画板，建议画布命名为资源文件名。Illustrator 中增加新画板对新手来说经常会忽视不齐像素，我用一个脚本把选中的图层转为画板并且自动对齐像素，最后用再另外一个脚本导出画板。如果图标很多，因为画板最多只能支持 100 个，这种方法还是有一些局限。你可以下载 <a href="https://github.com/Ashung/GUI_Automation_Toolbox/blob/master/Illustrator_Scripts/Artboards_To_SVG.jsx" target="_blank" rel="external">Selection_to_Artboard.jsx</a> (用于将选择图层转为画板) 和 <a href="https://github.com/Ashung/GUI_Automation_Toolbox/blob/master/Illustrator_Scripts/Selection_to_Artboard.jsx" target="_blank" rel="external">Artboards_To_SVG.jsx</a> (用于将画板导出为 SVG) 这两个脚本，它们仅适用于较小项目。</p>
<p>当项目较大时推荐使用 <a href="https://github.com/iconic/illustrator-svg-exporter" target="_blank" rel="external">Illustrator SVG Exporter</a>，这是一个只有选择保存路径对话框的 Illustrator 脚本，用于导出文档中带 “.svg” 后缀的路径、复合路径、组合、图层、画板等等，具体操作可见 <a href="https://github.com/iconic/illustrator-svg-exporter" target="_blank" rel="external">Illustrator SVG Exporter</a> 的项目主页。Illustrator SVG Exporter 导出的 SVG 是沿着内容边界裁切的，所以需要在组合或图层内包含一个矩形作为切图边界，这个矩形可以是无填充的路径，最后再统一去掉这个作为切图区域矩形的代码。</p>
<p><img src="//img.pfan123.com/screenshot_ai1.png" alt="svg优化"></p>
<p><a href="https://github.com/google/material-design-icons/" target="_blank" rel="external">Material design icons</a> 的 SVG 也带有多余的矩形的，应该是类似的导出方法。当图标数量巨大时，需要使用编程的方法来删除 SVG 文件内作为切图区域矩形的多余代码，除非团队里有很多人手，否则人工操作几乎不可能。Google 并没公布他们用的处理脚本。对代码恐惧，连运行代码都有难度的设计师而言，确实是很大挑战。选用画板导出方式则不需要处理这种问题，下文会介绍批量删除多余代码的方法。</p>
<p>Illustrator SVG Exporter 默认导出的 SVG 路径数据是精确到 4 位小数的，对于界面使用的小图标并不需要这么精确，可以通过修改源码，将精确度改为 1 或 2 位小数。代码大概在 41 行位置，找到svgOptions.coordinatePrecision = 4，将数值改为1或2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svgOptions.coordinatePrecision = 1;</span><br></pre></td></tr></table></figure>
<p>David Deraedt 的 <a href="https://github.com/davidderaedt/Illustrator-Layer-Exporter" target="_blank" rel="external">Layer Exporter</a> 是个拥有类似功能的 Illustrator 扩展，除了导出 SVG 外，还支持 PNG、JPG 格式，另外还提供一些简单的设置，具体使用方法可以查阅项目主页文档。</p>
<p>注意事项</p>
<ul>
<li>尽量把路径描边需要扩展为填充，除非确定需要使用描边的特性。</li>
<li>对于同一个图标，或者图标内同类元素尽量组合成复合路径或合并路径。</li>
<li>合理的编组或者图层，一个项目内的设计内容要么是按编组划分的，要么按图层划分，不要混用两种方式。</li>
<li>注意画板的坐标、路径节点的坐标尽量是整数。</li>
<li>不要用 Illustrator 打开 SVG 文件修改再保存，这样经常会导致保存后的 SVG 代码中 viewport、path 标签的数值偏移。</li>
</ul>
<h2 id="Photoshop-中使用-Generate-导出-SVG"><a href="#Photoshop-中使用-Generate-导出-SVG" class="headerlink" title="Photoshop 中使用 Generate 导出 SVG"></a>Photoshop 中使用 Generate 导出 SVG</h2><p>在 Photoshop CC 2015 可以使用画板导出 SVG，将画板大小作为切图区域，这样可以不需要额外图层作为边界。</p>
<p><img src="//img.pfan123.com/screenshot_ai2.png" alt="svg优化"></p>
<p>注意事项</p>
<ul>
<li>尽量把路径描边需要扩展为填充，除非确定需要使用描边的特性。</li>
<li>对于同一个图标，或者图标内同类元素尽量放在同一个矢量图层内。</li>
<li>因为 Photoshop 没有矢量预览功能，所以尽量注意路径结合处的细节。</li>
<li>Photoshop 导出的 SVG 代码不可设置，而且 SVG 代码中元素属性被分离成 CSS 样式。</li>
</ul>
<h2 id="Sketch-导出-SVG"><a href="#Sketch-导出-SVG" class="headerlink" title="Sketch 导出 SVG"></a>Sketch 导出 SVG</h2><p>如果使用 Sketch 导出 SVG 建议通过切片方式，并且切片不要包含在画板内(这张情况会导致 SVG 路径的数据是安装画板坐标生成的)。如果使用可导出图层就需要增加矩形图层作为切图边界，该图层不可以设置为无填充或者不可见，建议填充一个固定的色值。Sketch 的优点是导出不需要借助复制的脚本或插件。</p>
<p><img src="//img.pfan123.com/screenshot_ai3.png" alt="svg优化"></p>
<p>Sketch 导出的 SVG 代码冗余比较多且无法设置，而且经常增加一些奇怪的行为，如果画布中只有一个图层，Sketch 会将路径的数据加在路径父级的标签上。Github 上有一些清理 Sketch SVG 代码的工具，都没有界面的，对设计师来说又是挑战。</p>
<p>Github 上有一些清理 Sketch SVG 代码的工具，都是命令行工具或某个编程语言的模块/包，而不是 Sketch 插件。以下列出几个排名较高的清理工具。</p>
<ul>
<li><a href="https://github.com/overblog/clean-sketch" target="_blank" rel="external">clean-sketch</a>，Node.js 模块。</li>
<li><a href="https://github.com/overblog/gulp-clean-sketch" target="_blank" rel="external">gulp-clean-sketch</a> ，clean-sketch 的 gulp 插件。</li>
<li><a href="https://github.com/Warry/SketchCleaner" target="_blank" rel="external">Sketch SVG cleaner</a>， Node.js 命令行工具。</li>
<li><a href="https://github.com/aj0strow/clean-sketch-svg" target="_blank" rel="external">clean-sketch-svg</a>， Ruby 命令行工具。</li>
</ul>
<p>SVG 代码优化</p>
<p>设计软件导出的 SVG 都包含各种多余的代码，这会导致文件体积较大，一般最终使用的 SVG 都会对 SVG 进行优化处理。</p>
<p>常用的 SVG 代码优化工具 <a href="https://github.com/svg/svgo" target="_blank" rel="external">SVG Optimizer</a> (简称 SVGO) 是一个 Node.js 命令行工具。也就是说这是没有界面的，要在终端上敲代码来优化 SVG，这是非常高效处理方法，但对不熟悉命令行工具的设计师来说可能会有难度。熟悉命令行工具之后，会使用发现大部分界面工具的效率并不高，建议设计师最好花点时间熟悉下命令行工具操作方式。</p>
<p><a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="external">svgomg</a> 是 SVGO 的 Node.js 网页应用，有很多设置项，但每次只能优化一个 SVG 文件，如果网页速度太慢，可以下载源码后在本地搭建。</p>
<p><a href="https://github.com/svg/svgo-gui" target="_blank" rel="external">svgo-gui</a> 是 SVGO 的跨平台界面工具，但目前已不维护，官方推荐使用命令行或网页版本。</p>
<p>SVGO 相关的工具还有 Node.js 模块版本的<a href="https://github.com/imagemin/imagemin-svgo" target="_blank" rel="external">imagemin-svgo</a>，gulp 插件版本的<a href="https://github.com/ben-eb/gulp-svgmin" target="_blank" rel="external">gulp-svgmin</a>，项目主页上都有示例代码。</p>
<p><a href="https://github.com/RazrFalcon/SVGCleaner" target="_blank" rel="external">SVGCleaner</a> 另一个跨平台的带 GUI 界面的 SVG 优化软件，对命令行不熟悉的设计师可以选择这个软件。</p>
<p>参考资料:<br><a href="http://www.w3cplus.com/svg/svg-tips-for-designers.html" target="_blank" rel="external">创建和导出SVG的技巧</a><br><a href="https://ashung.github.io/stories/svg-export.html" target="_blank" rel="external">SVG 导出与优化</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SVG-icon、-导出优化/">SVG icon、 导出优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-移动端音频解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/01/移动端音频解决方案/" class="article-date">
  	<time datetime="2016-12-01T08:56:21.000Z" itemprop="datePublished">2016-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/01/移动端音频解决方案/">移动端H5音频解决方案</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="音频传输原理"><a href="#音频传输原理" class="headerlink" title="音频传输原理"></a>音频传输原理</h2><p>目前音频在互联网上的传输基于流媒体技术, 音频是流媒体的一种, 称其为流媒体是一种形象的比喻, 将数据的传输比作水流, “流”的重要作用体现在可以明显的节省时间, 实现边下载边播放, 而不需要下载完成后才进行播放。</p>
<ul>
<li>缓存</li>
</ul>
<p>流媒体的传输需要缓存, 因为Internet是一个分组交换网, 在其上面传输文件数据都要拆分成一个个数据包, 最后在接收端进行组装, 由于网络是动态变化的, 各个数据包选择的路由可能不尽相同, 故到达客户端的时间延迟也就不等, 先发的数据后到也是常有的事. 因此, 使用缓存来保证到达的数据包进行正确的排序, 从而使媒体数据能连续输出.</p>
<p>之前提到的边下边播, 也是在缓存中接收到足够的数据时才能进行播放的, 这一点在HTML5的文档中也有所体现.</p>
<p>[ 题外话: HTML5 media 文档中, 提到了两个事件 ‘canplay’ 和 ‘canplaythrough’. ‘canplay’: ‘表示浏览器已经加载了足够的数据去播放媒体文件, 但预计以后的播放可能会产生停顿去加载新的数据’ ‘canplaythrough’: ‘表示浏览器已经加载了足够的数据去播放媒体文件并且预计在播放中不会产生停顿去加载新的数据’ ]</p>
<ul>
<li>UDP<br>流媒体传输的实现需要合适的传输协议. 由于TCP需要较多的开销, 因此不太适合传输实时数据. 在流媒体传输的实现方案中一般采用HTTP/TCP来传输控制信息, 使用RTP/UDP来传输实时声音数据。</li>
</ul>
<h2 id="目前可使用的技术"><a href="#目前可使用的技术" class="headerlink" title="目前可使用的技术"></a>目前可使用的技术</h2><ul>
<li>Web Audio API<br>Web Auido API 是 JavaScript 中用于在网页应用中处理音频的一个高级应该用接口, 主要用于实现Web端的音频处理, 并可以同已存在的其他API相配合, 包括XMLHttpRequest, Canvas 2D 和 WebGL 3D API.</li>
</ul>
<p>其支持的功能包括</p>
<blockquote>
<p>支持各种类型的音频滤波器以实现各种音频效果, 包括回声, 消除噪音等<br>支持利用合成声音 (Sound synthesis) 创建电子音乐<br>支持3D位置音频模拟效果, 比如某种声音随着游戏场景而移动 (3D游戏中应该用处比较大…)<br>支持外部输入的声音与 WebRTC 进行集成<br>以及各种高端音频处理方法…</p>
</blockquote>
<p>但是…</p>
<p>由于移动端对其支持不是很完善 [ iOS已支持, 安卓原生浏览器目前还不支持 ], 目前还是使用支持广泛的 HTML5 Audio 好一些</p>
<p><img src="//7xrig5.com1.z0.glb.clouddn.com/web_audio_support-1.jpg" alt="Web Audio"></p>
<ul>
<li>HTML5 Audio 标签</li>
</ul>
<p>Audio 标签是 HTML5 新定义的一个元素, 提供了在 Web 端播放音频的很多功能. 虽然没有 Web Audio API 那么强大, 但足以满足日常音频播放需求, 更重要的是使浏览器原生支持音频播放, 而不依赖 Flash 或 Sliverlight 之类的外部插件。</p>
<p><img src="//7xrig5.com1.z0.glb.clouddn.com/audio_tag.jpg" alt="HTML5 Audio"></p>
<p>参考资料:<br><a href="http://goldfirestudios.com/blog/104/howler.js-Modern-Web-Audio-Javascript-Library" target="_blank" rel="external">howler.js</a><br><a href="https://github.com/goldfire/howler.js/" target="_blank" rel="external">howler.js github库</a><br><a href="https://www.awesomes.cn/repo/goldfire/howler-js" target="_blank" rel="external">howler.js中文介绍</a><br><a href="https://github.com/CreateJS/SoundJS" target="_blank" rel="external">SoundJS</a><br><a href="https://github.com/wangjx9110/document/blob/master/audio_summary.md" target="_blank" rel="external">移动端音频解决方案</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/howler-js、-video-js/">howler.js、 video.js</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-HTTP 代理原理及实现（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/25/HTTP 代理原理及实现（二）/" class="article-date">
  	<time datetime="2016-11-25T08:56:21.000Z" itemprop="datePublished">2016-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/25/HTTP 代理原理及实现（二）/">HTTP 代理原理及实现（二）转载</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上篇《<a href="http://blog.pfan123.com/2016/11/25/HTTP%20%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">HTTP 代理原理及实现（一）</a>》里，我介绍了 HTTP 代理的两种形式，并用 Node.js 实现了一个可用的普通 / 隧道代理。普通代理可以用来承载 HTTP 流量；隧道代理可以用来承载任何 TCP 流量，包括 HTTP 和 HTTPS。今天这篇文章介绍剩余部分：如何将浏览器与代理之间的流量传输升级为 HTTPS。</p>
<p>上篇文章中实现的代理，是一个标准的 HTTP 服务，针对浏览器的普通请求和 CONNECT 请求，进行不同的处理。Node.js 为创建 HTTP 或 HTTPS Server 提供了高度一致的接口，要将 HTTP 服务升级为 HTTPS 特别方便，只有一点点准备工作要做。</p>
<p>我们知道 TLS 有三大功能：内容加密、身份认证和数据完整性。其中内容加密依赖于密钥协商机制；数据完整性依赖于 MAC（Message authentication code）校验机制；而身份认证则依赖于证书认证机制。一般操作系统或浏览器会维护一个受信任根证书列表，包含在列表之中的证书，或者由列表中的证书签发的证书都会被客户端信任。</p>
<p>提供 HTTPS 服务的证书可以自己生成，然后手动加入到系统根证书列表中。但是对外提供服务的 HTTPS 网站，不可能要求每个用户都手动导入你的证书，所以更常见的做法是向 CA（Certificate Authority，证书颁发机构）申请。根据证书的不同级别，CA 会进行不同级别的验证，验证通过后 CA 会用他们的证书签发网站证书，这个过程通常是收费的（有免费的证书，最近免费的 Let’s Encrypt 也很火，这里不多介绍）。由于 CA 使用的证书都是由广泛内置在各系统中的根证书签发，所以从 CA 获得的网站证书会被绝大部分客户端信任。</p>
<p>通过 CA 申请证书很简单，本文为了方便演示，采用自己签发证书的偷懒办法。现在广泛使用的证书是 x509.v3 格式，使用以下命令可以创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private.pem 2048</span><br><span class="line">openssl req -new -x509 -key private.pem -out public.crt -days 99999</span><br></pre></td></tr></table></figure>
<p>第二行命令运行后，需要填写一些证书信息。需要注意的是<code>Common Name</code> 一定要填写后续提供<code>HTTPS</code>服务的域名或 IP。例如你打算在本地测试，<code>Common Name</code>可以填写<code>127.0.0.1</code>。证书创建好之后，再将<code>public.crt</code> 添加到系统受信任根证书列表中。为了确保添加成功，可以用浏览器验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![HTTP 代理](//st.imququ.com/i/webp/static/uploads/2015/11/fake_certificate.png.webp)</span><br></pre></td></tr></table></figure>
<p>接着，可以改造之前的 Node.js 代码了，需要改动的地方不多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var https = require(&apos;https&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">function request(cReq, cRes) &#123;</span><br><span class="line">    var u = url.parse(cReq.url);</span><br><span class="line"></span><br><span class="line">    var options = &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || 80,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method     : cReq.method,</span><br><span class="line">        headers     : cReq.headers</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var pReq = http.request(options, function(pRes) &#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function connect(cReq, cSock) &#123;</span><br><span class="line">    var u = url.parse(&apos;http://&apos; + cReq.url);</span><br><span class="line"></span><br><span class="line">    var pSock = net.connect(u.port, u.hostname, function() &#123;</span><br><span class="line">        cSock.write(&apos;HTTP/1.1 200 Connection Established\r\n\r\n&apos;);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    key: fs.readFileSync(&apos;./private.pem&apos;),</span><br><span class="line">    cert: fs.readFileSync(&apos;./public.crt&apos;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">https.createServer(options)</span><br><span class="line">    .on(&apos;request&apos;, request)</span><br><span class="line">    .on(&apos;connect&apos;, connect)</span><br><span class="line">    .listen(8888, &apos;0.0.0.0&apos;);</span><br></pre></td></tr></table></figure>
<p>可以看到，除了将<code>http.createServer</code>换成 <code>https.createServer</code>，增加证书相关配置之外，这段代码没有任何改变。这也是引入 TLS 层的妙处，应用层不需要任何改动，就能获得诸多安全特性。</p>
<p>运行服务后，只需要将浏览器的代理设置为<code>HTTPS 127.0.0.1:8888</code>即可，功能照旧。这样改造，只是将浏览器到代理之间的流量升级为了 HTTPS，代理自身逻辑、与服务端的通讯方式，都没有任何变化。</p>
<p>最后，还是写段 Node.js 代码验证下这个 HTTPS 代理服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var https = require(&apos;https&apos;);</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    hostname : &apos;127.0.0.1&apos;,</span><br><span class="line">    port     : 8888,</span><br><span class="line">    path     : &apos;imququ.com:80&apos;,</span><br><span class="line">    method     : &apos;CONNECT&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//禁用证书验证，不然自签名的证书无法建立 TLS 连接</span><br><span class="line">process.env.NODE_TLS_REJECT_UNAUTHORIZED = &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">var req = https.request(options);</span><br><span class="line"></span><br><span class="line">req.on(&apos;connect&apos;, function(res, socket) &#123;</span><br><span class="line">    socket.write(&apos;GET / HTTP/1.1\r\n&apos; +</span><br><span class="line">                 &apos;Host: imququ.com\r\n&apos; +</span><br><span class="line">                 &apos;Connection: Close\r\n&apos; +</span><br><span class="line">                 &apos;\r\n&apos;);</span><br><span class="line"></span><br><span class="line">    socket.on(&apos;data&apos;, function(chunk) &#123;</span><br><span class="line">        console.log(chunk.toString());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    socket.on(&apos;end&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;socket end.&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure></p>
<p>这段代码和上篇文章最后那段的区别只是<code>http.request</code>换成了<code>https.request</code>，运行结果完全一样，这里就不贴了。本文所有代码可以从这个仓库获得：<a href="https://github.com/qgy18/proxy-demo" target="_blank" rel="external">proxy-demo</a>。</p>
<p>参考资料:<br><a href="https://github.com/nodejitsu/node-http-proxy" target="_blank" rel="external">node-http-proxy</a><br><a href="https://segmentfault.com/q/1010000004652320" target="_blank" rel="external">node http-proxy和nginx代理性能对比?</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP、-node-http-proxy、-nginx、-proxy/">HTTP、 node-http-proxy、 nginx、 proxy</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-HTTP 代理原理及实现（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/25/HTTP 代理原理及实现（一）/" class="article-date">
  	<time datetime="2016-11-25T07:56:21.000Z" itemprop="datePublished">2016-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/25/HTTP 代理原理及实现（一）/">HTTP 代理原理及实现（一）转载</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Web 代理是一种存在于网络中间的实体，提供各式各样的功能。现代网络系统中，Web 代理无处不在。我之前有关 HTTP 的博文中，多次提到了代理对 HTTP 请求及响应的影响。今天这篇文章，我打算谈谈 HTTP 代理本身的一些原理，以及如何用 Node.js 快速实现代理。</p>
<p>HTTP 代理存在两种形式，分别简单介绍如下：<br>第一种是 ［RFC 7230 - HTTP/1.1: Message Syntax and Routing］(<a href="https://tools.ietf.org/html/rfc7230)（即修订后的" target="_blank" rel="external">https://tools.ietf.org/html/rfc7230)（即修订后的</a> RFC 2616，HTTP/1.1 协议的第一部分）描述的普通代理。这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。</p>
<p>第二种是 <a href="https://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01" target="_blank" rel="external">Tunneling TCP based protocols through Web proxy servers</a>（通过 Web 代理服务器用隧道方式传输基于 TCP 的协议）描述的隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接，但 CONNECT 最开始并不是 RFC 2616 - HTTP/1.1 的一部分，直到 2014 年发布的 HTTP/1.1 修订版中，才增加了对 CONNECT 及隧道代理的描述，详见 <a href="https://tools.ietf.org/html/rfc7231#section-4.3.6" target="_blank" rel="external">RFC 7231 - HTTP/1.1: Semantics and Content</a>。实际上这种代理早就被广泛实现。</p>
<h2 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h2><p>第一种 Web 代理原理特别简单：</p>
<blockquote>
<p>HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。</p>
</blockquote>
<p>下面这张图片来自于《HTTP 权威指南》，直观地展示了上述行为：</p>
<p><img src="//st.imququ.com/i/webp/static/uploads/2015/11/web_proxy.png.webp" alt="HTTP 代理"></p>
<p>假如我通过代理访问 A 网站，对于 A 来说，它会把代理当做客户端，完全察觉不到真正客户端的存在，这实现了隐藏客户端 IP 的目的。当然代理也可以修改 HTTP 请求头部，通过<code>X-Forwarded-IP</code>这样的自定义头部告诉服务端真正的客户端 IP。但服务器无法验证这个自定义头部真的是由代理添加，还是客户端修改了请求头，所以从 HTTP 头部字段获取 IP 时，需要格外小心。这部分内容可以参考我之前的《<a href="https://imququ.com/post/x-forwarded-for-header-in-http.html" target="_blank" rel="external">HTTP 请求头中的 X-Forwarded-For</a>》这篇文章。</p>
<p>给浏览器显式的指定代理，需要手动修改浏览器或操作系统相关设置，或者指定 PAC（Proxy Auto-Configuration，自动配置代理）文件自动设置，还有些浏览器支持 WPAD（Web Proxy Autodiscovery Protocol，Web 代理自动发现协议）。显式指定浏览器代理这种方式一般称之为正向代理，浏览器启用正向代理后，会对 HTTP 请求报文做一些修改，来规避老旧代理服务器的一些问题，这部分内容可以参考我之前的《<a href="https://imququ.com/post/the-proxy-connection-header-in-http-request.html" target="_blank" rel="external">Http 请求头中的 Proxy-Connection</a>》这篇文章。</p>
<p>还有一种情况是访问 A 网站时，实际上访问的是代理，代理收到请求报文后，再向真正提供服务的服务器发起请求，并将响应转发给浏览器。这种情况一般被称之为反向代理，它可以用来隐藏服务器 IP 及端口。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。反向代理是 Web 系统最为常见的一种部署方式，例如本博客就是使用 Nginx 的<code>proxy_pass</code> 功能将浏览器请求转发到背后的 Node.js 服务。</p>
<p>了解完第一种代理的基本原理后，我们用 Node.js 实现一下它。只包含核心逻辑的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">function request(cReq, cRes) &#123;</span><br><span class="line">    var u = url.parse(cReq.url);</span><br><span class="line"></span><br><span class="line">    var options = &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || 80,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method     : cReq.method,</span><br><span class="line">        headers     : cReq.headers</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var pReq = http.request(options, function(pRes) &#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer().on(&apos;request&apos;, request).listen(8888, &apos;0.0.0.0&apos;);</span><br></pre></td></tr></table></figure>
<p>以上代码运行后，会在本地<code>8888</code>端口开启 HTTP 代理服务，这个服务从请求报文中解析出请求 URL 和其他必要参数，新建到服务端的请求，并把代理收到的请求转发给新建的请求，最后再把服务端响应返回给浏览器。修改浏览器的 HTTP 代理为<code>127.0.0.1:8888</code>后再访问 HTTP 网站，代理可以正常工作。</p>
<p>但是，使用我们这个代理服务后，HTTPS 网站完全无法访问，这是为什么呢？答案很简单，这个代理提供的是 HTTP 服务，根本没办法承载 HTTPS 服务。那么是否把这个代理改为 HTTPS 就可以了呢？显然也不可以，因为这种代理的本质是中间人，而 HTTPS 网站的证书认证机制是中间人劫持的克星。普通的 HTTPS 服务中，服务端不验证客户端的证书，中间人可以作为客户端与服务端成功完成 TLS 握手；但是中间人没有证书私钥，无论如何也无法伪造成服务端跟客户端建立 TLS 连接。当然如果你拥有证书私钥，代理证书对应的 HTTPS 网站当然就没问题了。</p>
<p>HTTP 抓包神器 Fiddler 的工作原理也是在本地开启 HTTP 代理服务，通过让浏览器流量走这个代理，从而实现显示和修改 HTTP 包的功能。如果要让 Fiddler 解密 HTTPS 包的内容，需要先将它自带的根证书导入到系统受信任的根证书列表中。一旦完成这一步，浏览器就会信任 Fiddler 后续的「伪造证书」，从而在浏览器和 Fiddler、Fiddler 和服务端之间都能成功建立 TLS 连接。而对于 Fiddler 这个节点来说，两端的 TLS 流量都是可以解密的。</p>
<p>如果我们不导入根证书，Fiddler 的 HTTP 代理还能代理 HTTPS 流量么？实践证明，不导入根证书，Fiddler 只是无法解密 HTTPS 流量，HTTPS 网站还是可以正常访问。这是如何做到的，这些 HTTPS 流量是否安全呢？这些问题将在下一节揭晓。</p>
<h2 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h2><p>第二种 Web 代理的原理也很简单：</p>
<blockquote>
<p>HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。</p>
</blockquote>
<p>下面这张图片同样来自于《HTTP 权威指南》，直观地展示了上述行为：</p>
<p><img src="//st.imququ.com/i/webp/static/uploads/2015/11/web_tunnel.png.webp" alt="HTTP 代理"></p>
<p>假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。对于 HTTPS 来说，客户端透过代理直接跟服务端进行 TLS 握手协商密钥，所以依然是安全的，下图中的抓包信息显示了这种场景：</p>
<p><img src="//st.imququ.com/i/webp/static/uploads/2015/11/wireshark_connect.png.webp" alt="HTTP 代理"></p>
<p>可以看到，浏览器与代理进行 TCP 握手之后，发起了 CONNECT 请求，报文起始行如下：</p>
<blockquote>
<p>CONNECT imququ.com:443 HTTP/1.1</p>
</blockquote>
<p>对于 CONNECT 请求来说，只是用来让代理创建 TCP 连接，所以只需要提供服务器域名及端口即可，并不需要具体的资源路径。代理收到这样的请求后，需要与服务端建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：</p>
<blockquote>
<p>HTTP/1.1 200 Connection Established</p>
</blockquote>
<p>浏览器收到了这个响应报文，就可以认为到服务端的 TCP 连接已经打通，后续直接往这个 TCP 连接写协议数据即可。通过 Wireshark 的 Follow TCP Steam 功能，可以清楚地看到浏览器和代理之间的数据传递：</p>
<p><img src="//st.imququ.com/i/webp/static/uploads/2015/11/wireshark_connect_detail.png.webp" alt="HTTP 代理"></p>
<p>可以看到，浏览器建立到服务端 TCP 连接产生的 HTTP 往返，完全是明文，这也是为什么 CONNECT 请求只需要提供域名和端口：如果发送了完整 URL、Cookie 等信息，会被中间人一览无余，降低了 HTTPS 的安全性。HTTP 代理承载的 HTTPS 流量，应用数据要等到 TLS 握手成功之后通过 Application Data 协议传输，中间节点无法得知用于流量加密的 master-secret，无法解密数据。而 CONNECT 暴露的域名和端口，对于普通的 HTTPS 请求来说，中间人一样可以拿到（IP 和端口很容易拿到，请求的域名可以通过 DNS Query 或者 TLS Client Hello 中的 Server Name Indication 拿到），所以这种方式并没有增加不安全性。</p>
<p>了解完原理后，再用 Node.js 实现一个支持 CONNECT 的代理也很简单。核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">function connect(cReq, cSock) &#123;</span><br><span class="line">    var u = url.parse(&apos;http://&apos; + cReq.url);</span><br><span class="line"></span><br><span class="line">    var pSock = net.connect(u.port, u.hostname, function() &#123;</span><br><span class="line">        cSock.write(&apos;HTTP/1.1 200 Connection Established\r\n\r\n&apos;);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer().on(&apos;connect&apos;, connect).listen(8888, &apos;0.0.0.0&apos;);</span><br></pre></td></tr></table></figure>
<p>以上代码运行后，会在本地<code>8888</code>端口开启 HTTP 代理服务，这个服务从 CONNECT 请求报文中解析出域名和端口，创建到服务端的 TCP 连接，并和 CONNECT 请求中的 TCP 连接串起来，最后再响应一个 Connection Established 响应。修改浏览器的 HTTP 代理为<code>127.0.0.1:8888</code>后再访问 HTTPS 网站，代理可以正常工作。</p>
<p>最后，将两种代理的实现代码合二为一，就可以得到全功能的 Proxy 程序了，全部代码在 50 行以内（当然异常什么的基本没考虑，这是我博客代码的一贯风格）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">function request(cReq, cRes) &#123;</span><br><span class="line">    var u = url.parse(cReq.url);</span><br><span class="line"></span><br><span class="line">    var options = &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || 80,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method     : cReq.method,</span><br><span class="line">        headers     : cReq.headers</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var pReq = http.request(options, function(pRes) &#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function connect(cReq, cSock) &#123;</span><br><span class="line">    var u = url.parse(&apos;http://&apos; + cReq.url);</span><br><span class="line"></span><br><span class="line">    var pSock = net.connect(u.port, u.hostname, function() &#123;</span><br><span class="line">        cSock.write(&apos;HTTP/1.1 200 Connection Established\r\n\r\n&apos;);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer()</span><br><span class="line">    .on(&apos;request&apos;, request)</span><br><span class="line">    .on(&apos;connect&apos;, connect)</span><br><span class="line">    .listen(8888, &apos;0.0.0.0&apos;);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，大部分浏览器显式配置了代理之后，只会让 HTTPS 网站走隧道代理，这是因为建立隧道需要耗费一次往返，能不用就尽量不用。但这并不代表 HTTP 请求不能走隧道代理，我们用 Node.js 写段程序验证下（先运行前面的代理服务）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    hostname : &apos;127.0.0.1&apos;,</span><br><span class="line">    port     : 8888,</span><br><span class="line">    path     : &apos;imququ.com:80&apos;,</span><br><span class="line">    method     : &apos;CONNECT&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var req = http.request(options);</span><br><span class="line"></span><br><span class="line">req.on(&apos;connect&apos;, function(res, socket) &#123;</span><br><span class="line">    socket.write(&apos;GET / HTTP/1.1\r\n&apos; +</span><br><span class="line">                 &apos;Host: imququ.com\r\n&apos; +</span><br><span class="line">                 &apos;Connection: Close\r\n&apos; +</span><br><span class="line">                 &apos;\r\n&apos;);</span><br><span class="line"></span><br><span class="line">    socket.on(&apos;data&apos;, function(chunk) &#123;</span><br><span class="line">        console.log(chunk.toString());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    socket.on(&apos;end&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;socket end.&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure></p>
<p>这段代码运行完，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Thu, 19 Nov 2015 15:57:47 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 178</span><br><span class="line">Connection: close</span><br><span class="line">Location: https://imququ.com/</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">socket end.</span><br></pre></td></tr></table></figure></p>
<p>可以看到，通过 CONNECT 让代理打开到目标服务器的 TCP 连接，用来承载 HTTP 流量也是完全没问题的。</p>
<p>最后，HTTP 的认证机制可以跟代理配合使用，使得必须输入正确的用户名和密码才能使用代理，这部分内容比较简单，这里略过。在本文第二部分，我打算谈谈如何把今天实现的代理改造为 HTTPS 代理，也就是如何让浏览器与代理之间的流量走 HTTPS 安全机制。。</p>
<p>参考资料:<br><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="external">HTTP 代理原理及实现（一）</a><br><a href="https://imququ.com/post/web-proxy-2.html" target="_blank" rel="external">HTTP 代理原理及实现（二）</a><br><a href="https://github.com/nodejitsu/node-http-proxy" target="_blank" rel="external">node-http-proxy</a><br><a href="https://segmentfault.com/q/1010000004652320" target="_blank" rel="external">node http-proxy和nginx代理性能对比?</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP、-node-http-proxy、-nginx、-proxy/">HTTP、 node-http-proxy、 nginx、 proxy</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 pfan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>