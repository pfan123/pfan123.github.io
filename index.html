<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>pfan博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="pfan博客 新起点，新高度">
<meta property="og:type" content="website">
<meta property="og:title" content="pfan博客">
<meta property="og:url" content="http://pfan123.github.io/index.html">
<meta property="og:site_name" content="pfan博客">
<meta property="og:description" content="pfan博客 新起点，新高度">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="pfan博客">
<meta name="twitter:description" content="pfan博客 新起点，新高度">
  
    <link rel="alternative" href="/atom.xml" title="pfan博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://litten.github.io/assets/blogImg/litten.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">pfan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">新起点，新高度</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>		
					
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>

			</div>
		


		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
				        	<li class = "article_cate_tit"> 文章分类</li>
				        	<li class = "article_cate_a"> <a  href = "/categories/技术杂谈/">技术杂谈</a>	</li>
				        	<li class = "article_cate_a"> <a href = "/categories/兴趣爱好/">兴趣爱好</a>		</li>
				        	<li class = "article_cate_a"> <a href = "/categories/日志/">日志</a></li>
				        	<li class = "article_cate_a"> <a href = "/categories/JavaScript/">JavaScript</a>	</li>
				        	<li class = "article_cate_a"> <a  href = "/categories/CSS3/">CSS3</a>	</li>
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/pfan123" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/gaolu1990/home?wvr=5" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>



				<style type="text/css">
					.article_cate_tit{
						color:#ba8f6c;
						margin-top:6px;
					}
					.article_cate_con a{
						display:block;
						font-size:12px;
						text-align:center;
						margin:4px 0;
					}
					#header .header-menu{
						line-height:21px;
					}
					.article_cate_a{
						line-height:18px !important;
					}	
					.article_cate_a a{
						font-size:12px !important;
					}				
					#container .left-col .overlay{
						height:130px;
					}
					.header-nav{
						top:160px;
					}
				</style>	
				<!-- E 新增模块-->
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/gitignore-git/" style="font-size: 10px;">.gitignore git</a> <a href="/tags/htaccess-配置二级域名-绑定子目录/" style="font-size: 10px;">.htaccess  配置二级域名  绑定子目录</a> <a href="/tags/AMD/" style="font-size: 10px;">AMD</a> <a href="/tags/CMD/" style="font-size: 10px;">CMD</a> <a href="/tags/CSS-BEM-OOCSS/" style="font-size: 10px;">CSS BEM OOCSS</a> <a href="/tags/CSS动画篇/" style="font-size: 10px;">CSS动画篇</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/ESLint/" style="font-size: 10px;">ESLint</a> <a href="/tags/Git，Git查看历史记录/" style="font-size: 10px;">Git，Git查看历史记录</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/H5-视频直播-video/" style="font-size: 10px;">H5 视频直播 video</a> <a href="/tags/H5全景、CSS3d、perspective/" style="font-size: 20px;">H5全景、CSS3d、perspective</a> <a href="/tags/HLS、RTMP协议/" style="font-size: 10px;">HLS、RTMP协议</a> <a href="/tags/HTML5/" style="font-size: 20px;">HTML5</a> <a href="/tags/HTML5-视频直播-video-canvas/" style="font-size: 10px;">HTML5 视频直播 video canvas</a> <a href="/tags/HTML5、localstorage、sessionStorage/" style="font-size: 10px;">HTML5、localstorage、sessionStorage</a> <a href="/tags/HTML、XML解析、dom-level、htmlparser2、xmldom、sax-js、cheerio/" style="font-size: 10px;">HTML、XML解析、dom level、htmlparser2、xmldom、sax-js、cheerio</a> <a href="/tags/HTTP、-node-http-proxy、-nginx、-proxy/" style="font-size: 20px;">HTTP、 node-http-proxy、 nginx、 proxy</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Mac-命令-Terminal-osx/" style="font-size: 10px;">Mac 命令 Terminal osx</a> <a href="/tags/Mac、root/" style="font-size: 10px;">Mac、root</a> <a href="/tags/Math-atan-、Math-atan2-斜率/" style="font-size: 10px;">Math.atan()、Math.atan2() 斜率</a> <a href="/tags/Mongoose参考手册-MongoDB-数据库-node/" style="font-size: 10px;">Mongoose参考手册  MongoDB  数据库 node</a> <a href="/tags/Nginx-负载均衡/" style="font-size: 10px;">Nginx  负载均衡</a> <a href="/tags/Nginx-负载均衡-node-jdc-解决方案-host/" style="font-size: 10px;">Nginx  负载均衡 node  jdc 解决方案 host</a> <a href="/tags/Nginx-Mac-Node/" style="font-size: 10px;">Nginx Mac Node</a> <a href="/tags/Nginx-MySQL-PHP-FPM-Mac-OS/" style="font-size: 10px;">Nginx MySQL PHP-FPM Mac OS</a> <a href="/tags/Nodejs学习实践-nodejs-ES6/" style="font-size: 10px;">Nodejs学习实践 nodejs  ES6</a> <a href="/tags/PreloadJS-EaselJS-TweenJS-SoundJS/" style="font-size: 10px;">PreloadJS EaselJS TweenJS SoundJS</a> <a href="/tags/SVG-Sprites-Symbols/" style="font-size: 10px;">SVG Sprites Symbols</a> <a href="/tags/SVG-icon、-导出优化/" style="font-size: 10px;">SVG icon、 导出优化</a> <a href="/tags/SVG、dataURI、base64/" style="font-size: 10px;">SVG、dataURI、base64</a> <a href="/tags/UMD/" style="font-size: 10px;">UMD</a> <a href="/tags/Vim-vi/" style="font-size: 10px;">Vim vi</a> <a href="/tags/createJS/" style="font-size: 10px;">createJS</a> <a href="/tags/css-modules-scope-模块化/" style="font-size: 10px;">css modules  scope  模块化</a> <a href="/tags/deviceorientation、orientationchange-重力感应/" style="font-size: 10px;">deviceorientation、orientationchange 重力感应</a> <a href="/tags/deviceorientation、orientationchange-重力感应-CSS3D/" style="font-size: 10px;">deviceorientation、orientationchange 重力感应 CSS3D</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hexo初始/" style="font-size: 10px;">hexo初始</a> <a href="/tags/hexo相关问题/" style="font-size: 10px;">hexo相关问题</a> <a href="/tags/howler-js、-video-js/" style="font-size: 10px;">howler.js、 video.js</a> <a href="/tags/insertAdjacentHTML方法/" style="font-size: 10px;">insertAdjacentHTML方法</a> <a href="/tags/insertAdjacentText方法/" style="font-size: 10px;">insertAdjacentText方法</a> <a href="/tags/javascript、canvas、toDataURL/" style="font-size: 10px;">javascript、canvas、toDataURL()</a> <a href="/tags/mac-iphone-铃声/" style="font-size: 10px;">mac iphone 铃声</a> <a href="/tags/node-版本管理-nvm-n/" style="font-size: 10px;">node 版本管理  nvm  n</a> <a href="/tags/node-读写excel-JS-XLSX-分析excel写入/" style="font-size: 10px;">node 读写excel JS-XLSX 分析excel写入</a> <a href="/tags/pm2学习实践-nodejs-pm2/" style="font-size: 10px;">pm2学习实践 nodejs pm2</a> <a href="/tags/react-flux-redux-ECMAScript6-Vue-Angular-Angular2-0-NuclearJS/" style="font-size: 10px;">react flux redux ECMAScript6 Vue Angular Angular2.0 NuclearJS</a> <a href="/tags/ssh常用命令-SSH/" style="font-size: 10px;">ssh常用命令  SSH</a> <a href="/tags/svg、path、circle、rect、ellipse、polygon、polyline、line/" style="font-size: 10px;">svg、path、circle、rect、ellipse、polygon、polyline、line</a> <a href="/tags/video-canvas/" style="font-size: 10px;">video canvas</a> <a href="/tags/vue-router-vue/" style="font-size: 10px;">vue-router, vue</a> <a href="/tags/webp/" style="font-size: 10px;">webp</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/三角学、弧度、角度/" style="font-size: 10px;">三角学、弧度、角度</a> <a href="/tags/买房前必备知识-house-home/" style="font-size: 10px;">买房前必备知识  house home</a> <a href="/tags/买车前必备知识-car/" style="font-size: 10px;">买车前必备知识  car</a> <a href="/tags/京东购物H5活动CP重构规范/" style="font-size: 10px;">京东购物H5活动CP重构规范</a> <a href="/tags/优化JavaScript的执行效率/" style="font-size: 10px;">优化JavaScript的执行效率</a> <a href="/tags/前端性能优化/" style="font-size: 10px;">前端性能优化</a> <a href="/tags/吉他/" style="font-size: 10px;">吉他</a> <a href="/tags/吉他知识/" style="font-size: 10px;">吉他知识</a> <a href="/tags/学吉他知识集锦/" style="font-size: 10px;">学吉他知识集锦</a> <a href="/tags/旅游-帝都畅游-相约北京/" style="font-size: 10px;">旅游 帝都畅游 相约北京</a> <a href="/tags/模块的写法/" style="font-size: 10px;">模块的写法</a> <a href="/tags/运营规范/" style="font-size: 10px;">运营规范</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/pingfan1990/">博客园博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.w3cfuns.com/house.php">前端网博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://pingfan1990.sinaapp.com/">pfan展示平台</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://doc.pfan123.com/">pfan前端开发导航平台</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">因上努力，果上随缘</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">pfan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://litten.github.io/assets/blogImg/litten.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">pfan</h1>
			</hgroup>
			
			<p class="header-subtitle">新起点，新高度</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/pfan123" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/gaolu1990/home?wvr=5" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-SVG 基本形状与路径" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/16/SVG 基本形状与路径/" class="article-date">
  	<time datetime="2017-01-16T01:10:21.000Z" itemprop="datePublished">2017-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/SVG 基本形状与路径/">聊聊 SVG 基本形状转换那些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间研究 SVG 压缩优化，发现SVG预定义的 <code>rect</code>、<code>circle</code>、<code>ellipse</code>、<code>line</code>、<code>polyline</code>、<code>polygon</code>  六种基本形状可通过path路径转换实现，这样可以在一定程度上减少代码量。不仅如此，我们常用的 SVG Path 动画(路径动画)，是以操作path中两个属性值<code>stroke-dasharray</code>和<code>stroke-dashoffset</code>来实现，基本形状转换为path路径，有利于实现路径动画。</p>
<h2 id="SVG基本形状"><a href="#SVG基本形状" class="headerlink" title="SVG基本形状"></a>SVG基本形状</h2><p>SVG 提供了<code>rect</code>、<code>circle</code>、<code>ellipse</code>、<code>line</code>、<code>polyline</code>、<code>polygon</code>六种基本形状用于图形绘制，这些形状可以直接用来绘制一些基本的形状，如矩形、椭圆等，而复杂图形的绘制则需要使用 path 路径来实现。</p>
<p><img src="http://img.pfan123.com/svgpath1.jpg" alt="svg基本形状"></p>
<h3 id="1-rect-矩形"><a href="#1-rect-矩形" class="headerlink" title="1.rect 矩形"></a>1.<code>rect</code> 矩形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;</span><br><span class="line">&lt;rect x=&quot;60&quot; y=&quot;10&quot; rx=&quot;10&quot; ry=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>SVG中<code>rect</code>元素用于绘制矩形、圆角矩形，含有6个基本属性用于控制矩形的形状以及坐标，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x       矩形左上角x位置, 默认值为 0 </span><br><span class="line">y       矩形左上角y位置, 默认值为 0</span><br><span class="line">width   矩形的宽度, 不能为负值否则报错, 0 值不绘制</span><br><span class="line">height  矩形的高度,  不能为负值否则报错, 0 值不绘制</span><br><span class="line">rx      圆角x方向半径, 不能为负值否则报错</span><br><span class="line">ry      圆角y方向半径, 不能为负值否则报错</span><br></pre></td></tr></table></figure>
<p>这里需要注意，<code>rx</code> 和 <code>ry</code> 的还有如下规则：</p>
<ul>
<li><code>rx</code> 和 <code>ry</code> 都没有设置, 则 rx = 0 ry = 0</li>
<li><code>rx</code> 和 <code>ry</code> 有一个值为0, 则相当于 rx = 0 ry = 0，圆角无效</li>
<li><code>rx</code> 和 <code>ry</code> 有一个被设置, 则全部取这个被设置的值</li>
<li><code>rx</code> 的最大值为 <code>width</code> 的一半, <code>ry</code> 的最大值为 <code>height</code> 的一半</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rx = rx || ry || 0;</span><br><span class="line">ry = ry || rx || 0;</span><br><span class="line"></span><br><span class="line">rx = rx &gt; width / 2 ? width / 2 : rx;</span><br><span class="line">ry = ry &gt; height / 2 ? height / 2 : ry;</span><br><span class="line"></span><br><span class="line">if(0 === rx || 0 === ry)&#123;</span><br><span class="line"> rx = 0,</span><br><span class="line"> ry = 0;  //圆角不生效，等同于，rx，ry都为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-circle-圆形"><a href="#2-circle-圆形" class="headerlink" title="2.circle 圆形"></a>2.<code>circle</code> 圆形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;#fff&quot;&gt;&lt;/circle&gt;</span><br></pre></td></tr></table></figure>
<p>SVG中<code>circle</code>元素用于绘制圆形，含有3个基本属性用于控制圆形的坐标以及半径，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r       半径</span><br><span class="line">cx      圆心x位置, 默认为 0</span><br><span class="line">cy      圆心y位置, 默认为 0</span><br></pre></td></tr></table></figure>
<h3 id="3-ellipse-椭圆"><a href="#3-ellipse-椭圆" class="headerlink" title="3.ellipse 椭圆"></a>3.<code>ellipse</code> 椭圆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ellipse cx=&quot;75&quot; cy=&quot;75&quot; rx=&quot;20&quot; ry=&quot;5&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>SVG中<code>ellipse</code>元素用于绘制椭圆，是<code>circle</code>元素更通用的形式，含有4个基本属性用于控制椭圆的形状以及坐标，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rx      椭圆x半径</span><br><span class="line">ry      椭圆y半径</span><br><span class="line">cx      圆心x位置, 默认为 0</span><br><span class="line">cy      圆心y位置, 默认为 0</span><br></pre></td></tr></table></figure>
<h3 id="4-line-直线"><a href="#4-line-直线" class="headerlink" title="4.line 直线"></a>4.<code>line</code> 直线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;line x1=&quot;10&quot; x2=&quot;50&quot; y1=&quot;110&quot; y2=&quot;150&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><code>Line</code>绘制直线。它取两个点的位置作为属性，指定这条线的起点和终点位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1 起点的x位置</span><br><span class="line">y1 起点的y位置</span><br><span class="line">x2 终点的x位置</span><br><span class="line">y2 终点的y位置</span><br></pre></td></tr></table></figure>
<h3 id="5-polyline-折线"><a href="#5-polyline-折线" class="headerlink" title="5.polyline 折线"></a>5.<code>polyline</code> 折线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;polyline points=&quot;60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><code>polyline</code>是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个points属性中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2”</span><br></pre></td></tr></table></figure>
<h3 id="6-polygon-多边形"><a href="#6-polygon-多边形" class="headerlink" title="6.polygon 多边形"></a>6.<code>polygon</code> 多边形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;polygon points=&quot;50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><code>polygon</code>和折线很像，它们都是由连接一组点集的直线构成。不同的是，<code>polygon</code>的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2， 路径绘制完闭合图形”</span><br></pre></td></tr></table></figure>
<h2 id="SVG-path-路径"><a href="#SVG-path-路径" class="headerlink" title="SVG path 路径"></a>SVG path 路径</h2><p>SVG 的路径<code>&lt;path&gt;</code>功能非常强大，它不仅能创建其他基本形状，还能创建更多复杂的形状。<code>&lt;path&gt;</code>路径是由一些命令来控制的，每一个命令对应一个字母，并且区分大小写，大写主要表示绝对定位，小写表示相对定位。<code>&lt;path&gt;</code> 通过属性 d 来定义路径， d 是一系列命令的集合，主要有以下几个命令：</p>
<p><img src="http://img.pfan123.com/svgpath2.jpg" alt="svg基本形状"></p>
<p>通常大部分形状，都可以通过指令<code>M(m)</code>、<code>L(l)</code>、<code>H(h)</code>、<code>V(v)</code>、<code>A(a)</code>来实现，注意特别要区分大小写，相对与绝对坐标情况，转换时推荐使用相对路径可减少代码量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以下两个等价</span><br><span class="line">d=&apos;M 10 10 20 20&apos;     // (10, 10) (20 20) 都是绝对坐标</span><br><span class="line">d=&apos;M 10 10 L 20 20&apos;</span><br><span class="line"></span><br><span class="line">// 以下两个等价</span><br><span class="line">d=&apos;m 10 10 20 20&apos;     // (10, 10) 绝对坐标, (20 20) 相对坐标</span><br><span class="line">d=&apos;M 10 10 l 20 20&apos;</span><br></pre></td></tr></table></figure>
<h2 id="SVG-基本形状路径转换原理"><a href="#SVG-基本形状路径转换原理" class="headerlink" title="SVG 基本形状路径转换原理"></a>SVG 基本形状路径转换原理</h2><h3 id="1-rect-to-path"><a href="#1-rect-to-path" class="headerlink" title="1.rect to path"></a>1.rect to path</h3><p>如下图所示，一个 <code>rect</code> 是由 4 个弧和 4 个线段构成；如果 <code>rect</code> 没有设置 rx 和 ry 则 <code>rect</code> 只是由 4 个线段构成。<code>rect</code> 转换为 <code>path</code> 只需要将 A ~ H 之间的弧和线段依次实现即可。</p>
<p><img src="http://img.pfan123.com/rect2path.png" alt="svg基本形状"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function rect2path(x, y, width, height, rx, ry) &#123;</span><br><span class="line">    /*</span><br><span class="line">    * rx 和 ry 的规则是：</span><br><span class="line">    * 1. 如果其中一个设置为 0 则圆角不生效</span><br><span class="line">    * 2. 如果有一个没有设置则取值为另一个</span><br><span class="line">    */</span><br><span class="line">    rx = rx || ry || 0;</span><br><span class="line">    ry = ry || rx || 0;</span><br><span class="line"></span><br><span class="line">   //非数值单位计算，如当宽度像100%则移除</span><br><span class="line">   if (isNaN(x - y + width - height + rx - ry)) return;</span><br><span class="line"></span><br><span class="line">   rx = rx &gt; width / 2 ? width / 2 : rx;</span><br><span class="line">   ry = ry &gt; height / 2 ? height / 2 : ry;</span><br><span class="line"></span><br><span class="line">   //如果其中一个设置为 0 则圆角不生效</span><br><span class="line">   if(0 == rx || 0 == ry)&#123;</span><br><span class="line">         // var path =</span><br><span class="line">         //     &apos;M&apos; + x + &apos; &apos; + y +</span><br><span class="line">         //     &apos;H&apos; + (x + width) +     不推荐用绝对路径，相对路径节省代码量</span><br><span class="line">         //     &apos;V&apos; + (y + height) +</span><br><span class="line">         //     &apos;H&apos; + x +</span><br><span class="line">         //     &apos;z&apos;;</span><br><span class="line">         var path =</span><br><span class="line">             &apos;M&apos; + x + &apos; &apos; + y +</span><br><span class="line">             &apos;h&apos; + width +</span><br><span class="line">             &apos;v&apos; + height +</span><br><span class="line">             &apos;h&apos; + -width +</span><br><span class="line">             &apos;z&apos;;                </span><br><span class="line">   &#125;else&#123;</span><br><span class="line">         var path =</span><br><span class="line">             &apos;M&apos; + x + &apos; &apos; + (y+ry) +</span><br><span class="line">             &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 0 1 &apos; + rx + &apos; &apos; + (-ry) + </span><br><span class="line">             &apos;h&apos; + (width - rx - rx) +</span><br><span class="line">             &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 0 1 &apos; + rx + &apos; &apos; + ry + </span><br><span class="line">             &apos;v&apos; + (height - ry -ry) +</span><br><span class="line">             &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 0 1 &apos; + (-rx) + &apos; &apos; + ry + </span><br><span class="line">             &apos;h&apos; + (rx + rx -width) +</span><br><span class="line">             &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 0 1 &apos; + (-rx) + &apos; &apos; + (-ry) + </span><br><span class="line">             &apos;z&apos;;        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-circle-ellipse-to-path"><a href="#2-circle-ellipse-to-path" class="headerlink" title="2.circle/ellipse to path"></a>2.circle/ellipse to path</h4><p>圆可视为是一种特殊的椭圆，即 rx 与 ry 相等的椭圆，所以可以放在一起讨论。 椭圆可以看成A点到C做180度顺时针画弧、C点到A做180度顺时针画弧即可。</p>
<p><img src="//misc.aotu.io/pfan123/svgpath/ellipse2path.png" alt="svg基本形状"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ellipse2path(cx, cy, rx, ry) &#123;</span><br><span class="line">   //非数值单位计算，如当宽度像100%则移除</span><br><span class="line">   if (isNaN(cx - cy + rx - ry)) return;</span><br><span class="line"></span><br><span class="line">   var path =</span><br><span class="line">       &apos;M&apos; + (cx-rx) + &apos; &apos; + cy +</span><br><span class="line">       &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 1 0 &apos; + 2*rx + &apos; 0&apos; +</span><br><span class="line">       &apos;a&apos; + rx + &apos; &apos; + ry + &apos; 0 1 0 &apos; + (-2*rx) + &apos; 0&apos; +</span><br><span class="line">       &apos;z&apos;; </span><br><span class="line"></span><br><span class="line">   return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-line-to-path"><a href="#3-line-to-path" class="headerlink" title="3.line to path"></a>3.line to path</h4><p>相对来说比较简单，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function line2path(x1, y1, x2, y2) &#123;</span><br><span class="line">   //非数值单位计算，如当宽度像100%则移除</span><br><span class="line">   if (isNaN(x1 - y1 + x2 - y2)) return; </span><br><span class="line">   </span><br><span class="line">    x1 = x1 || 0;</span><br><span class="line">    y1 = y1 || 0;</span><br><span class="line">    x2 = x2 || 0;</span><br><span class="line">    y2 = y2 || 0;</span><br><span class="line"></span><br><span class="line">    var path = &apos;M&apos; + x1 + &apos; &apos;+ y1 + &apos;L&apos; + x2 + &apos; &apos; + y2;</span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-polyline-polygon-to-path"><a href="#4-polyline-polygon-to-path" class="headerlink" title="4.polyline/polygon to path"></a>4.polyline/polygon to path</h3><p><code>polyline</code>折线、<code>polygon</code>多边形的转换为path比较类似，差别就是<code>polygon</code>多边形会闭合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// polygon折线转换</span><br><span class="line">points = [x1, y1, x2, y2, x3, y3 ...];</span><br><span class="line">function polyline2path (points) &#123;</span><br><span class="line">    var path = &apos;M&apos; + points.slice(0,2).join(&apos; &apos;) +</span><br><span class="line">                      &apos;L&apos; + points.slice(2).join(&apos; &apos;); </span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// polygon多边形转换</span><br><span class="line">points = [x1, y1, x2, y2, x3, y3 ...];</span><br><span class="line">function polygon2path (points) &#123;</span><br><span class="line">    var path = &apos;M&apos; + points.slice(0,2).join(&apos; &apos;) +</span><br><span class="line">                      &apos;L&apos; + points.slice(2).join(&apos; &apos;) + &apos;z&apos;; </span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="convertpath转换工具"><a href="#convertpath转换工具" class="headerlink" title="convertpath转换工具"></a><code>convertpath</code>转换工具</h3><p>为了方便处理SVG基本元素路径转换，本人抽空写了<a href="https://github.com/pfan123/convertpath" target="_blank" rel="external">convertpath</a>工具，具体如下：</p>
<p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i convertpath</span><br></pre></td></tr></table></figure></p>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const parse = require(&apos;convertpath&apos;);</span><br><span class="line">parse.parse(&quot;./test/test.svg&quot;)</span><br><span class="line">/**</span><br><span class="line"> * &lt;circle cx=&quot;500&quot; cy=&quot;500&quot; r=&quot;20&quot; fill=&quot;red&quot;/&gt;</span><br><span class="line"> */</span><br><span class="line">console.log(parse.toSimpleSvg())</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;path d=&quot;M500,500,m-20,0,a20,20,0,1,0,40,0,a20,20,0,1,0,-40,0,Z&quot; fill=&quot;red&quot;/&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="https://www.w3.org/TR/SVG/shapes.html" target="_blank" rel="external">Basic Shapes – SVG 1.1 (Second Edition)</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Basic_Shapes" target="_blank" rel="external">基本形状 - SVG | MDN</a><br><a href="https://segmentfault.com/a/1190000004393817" target="_blank" rel="external">SVG (一) 图形, 路径, 变换总结; 以及椭圆弧线, 贝塞尔曲线的详细解释</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths" target="_blank" rel="external">路径 - SVG | MDN</a><br><a href="https://github.com/jindw/xmldom" target="_blank" rel="external">XMLDOM</a>   </p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/svg、path、circle、rect、ellipse、polygon、polyline、line/">svg、path、circle、rect、ellipse、polygon、polyline、line</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-dataURI 中使用 SVG正确姿势" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/11/dataURI 中使用 SVG正确姿势/" class="article-date">
  	<time datetime="2017-01-11T03:00:21.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/dataURI 中使用 SVG正确姿势/">探究 dataURI 中使用 SVG 正确姿势</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了减少首页的请求数量，按照以往的思路，会直接将 SVG 转换为 base64 后插入了 CSS 文件中。代码可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.svg &#123;</span><br><span class="line">    background-image: url(&apos;data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjUwOCIgaGVpZ2h0PSIyNTIuNyIgdmlld0JveD0iMCAwIDI1MDggMjUyLjciPjxwb2x5Z29uIHBvaW50cz0iNCwyNTIuNyAyNTA0LDAgMjUwNCwyNTIuNyIgc3R5bGU9ImZpbGw6I2U2ZWJlYSIgLz48L3N2Zz4=&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初步开发完成后，为了进一步优化代码，在查询资料时读到了这篇文章：<a href="http://codepen.io/Tigt/post/optimizing-svgs-in-data-uris" target="_blank" rel="external">Optimizing SVGs in data URIs</a>。参考文章内容进行优化之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.svg &#123;</span><br><span class="line">    background-image: url(&quot;data:image/svg+xml;charset=utf8,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; version=&apos;1.1&apos;%3E%3Cpolygon points=&apos;4,252.7 2504,0 2504,252.7&apos; style=&apos;fill:%23e6ebea&apos;/%3E%3C/svg%3E&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比这两段代码，最明显的效果是代码量减少了一半多，而且代码非常清晰，几乎就是 SVG 代码原文，日后如果有一些细微的需求变更，比如更改填充色，可以直接在代码里修改无需进行编码转换。</p>
<h2 id="在-dataURI-中使用-SVG-的最佳方法-Optimizing-SVGs-in-data-URIs"><a href="#在-dataURI-中使用-SVG-的最佳方法-Optimizing-SVGs-in-data-URIs" class="headerlink" title="在 dataURI 中使用 SVG 的最佳方法 Optimizing SVGs in data URIs"></a>在 dataURI 中使用 SVG 的最佳方法 <a href="http://codepen.io/Tigt/post/optimizing-svgs-in-data-uris" target="_blank" rel="external">Optimizing SVGs in data URIs</a></h2><p>不久前，CSS-Tricks 发表了 <a href="https://css-tricks.com/probably-dont-base64-svg/" target="_blank" rel="external">“Probably Don’t Base64 SVG”</a>，得出结论：如果你在 data URI 中直接使用 SVG，数据量会比转化成 base64 编码格式时小。</p>
<p>这个观点是正确的，但是这里还有一些复杂的地方以及可优化的空间。</p>
<h2 id="更好的浏览器兼容性"><a href="#更好的浏览器兼容性" class="headerlink" title="更好的浏览器兼容性"></a>更好的浏览器兼容性</h2><p>例如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bg &#123;</span><br><span class="line">    background: url(&apos;data:image/svg+xml;utf8,&lt;svg ...&gt; ... &lt;/svg&gt;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在那些流行于 web 开发者中的浏览器中是有效的，但是在 IE 中则无法正常工作。因为从技术角度来说这是一种畸形的 data URI，而 IE 很严格（原文： This is because technically it’s a malformed data URI, and IE is being strict.）。</p>
<h3 id="RFC-2397-定义了-data-URI："><a href="#RFC-2397-定义了-data-URI：" class="headerlink" title="RFC 2397 定义了 data URI："></a><a href="http://www.ietf.org/rfc/rfc2397.txt" target="_blank" rel="external">RFC 2397</a> 定义了 data URI：</h3><blockquote>
<p>URL 的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;mediatype&gt;</code> 描述数据的 MIME 类型，<code>;base64</code> 的出现意味着数据被编码成 <code>base64</code> 格式。如果没有声明<code>;base64</code>，对于 URL 安全字符使用 ASCII 编码，而安全范围以外的字符则使用十六进制数编码为<code>%xx</code>格式。如果省略<code>&lt;mediatype&gt;</code>，默认为<code>text/plain;charset=US-ASCII</code>。</p>
</blockquote>
<p>换句话说，根据标准，只有如下两种编码 data URI 的方法是有效的：</p>
<ul>
<li>1.<code>data:mime/type;base64,[actual data]</code>：base64 编码，更适合于二进制数据（PNG，fonts，SVGZ 等等）</li>
<li>2.<code>data:mime/type;charset=[charset],[actual data]</code>：URL 编码的普通文本，更适合与文本标记语言（SVG，HTML等）</li>
</ul>
<p>所以，把一个 SVG 文件编码为 data URL 的正确方式为 <code>data:image/svg+xml;charset=utf8,[actual data]</code>。我猜大部分浏览器对是否存在<code>charset=</code>字符串比较宽容，但是在 IE 浏览器里是必须的。为了代码的最大兼容性（例如一些小众浏览器，邮件客户端，等等），它应该被包含在内。</p>
<p>但这并不是全部。记得这段话么？</p>
<blockquote>
<p>如果没有声明<code>;base64</code>，对于 URL 安全字符使用<code>ASCII</code> 编码，而安全范围以外的字符则使用十六进制数编码为<code>%xx</code>格式。如果省略<code>&lt;mediatype&gt;</code>，默认为<code>text/plain;charset=US-ASCII</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!-- Generated by IcoMoon.io --&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line">&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;512&quot; height=&quot;512&quot; viewBox=&quot;0 0 512 512&quot;&gt;&lt;g id=&quot;icomoon-ignore&quot;&gt;</span><br><span class="line">&lt;/g&gt;</span><br><span class="line">&lt;path d=&quot;M224 387.814v124.186l-192-192 192-192v126.912c223.375 5.24 213.794-151.896 156.931-254.912 140.355 151.707 110.55 394.785-156.931 387.814z&quot;&gt;&lt;/path&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>根据 Chris 的建议，我们使用 <a href="https://github.com/svg/svgo" target="_blank" rel="external">SVGO</a> 来优化我们的 SVG 文件（如果你更习惯图形界面，GUI 版本：<a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="external">SCGOMG</a>）。结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;512&quot; height=&quot;512&quot; viewBox=&quot;0 0 512 512&quot;&gt;&lt;path d=&quot;M224 387.814V512L32 320l192-192v126.912C447.375 260.152 437.794 103.016 380.93 0 521.287 151.707 491.48 394.785 224 387.814z&quot;/&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>文件小了很多！而且如果你打算用 CSS 来设定图像的尺寸，你还可以去掉<code>width</code>和<code>height</code>属性让代码更简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 512 512&quot;&gt;&lt;path d=&quot;M224 387.814V512L32 320l192-192v126.912C447.375 260.152 437.794 103.016 380.93 0 521.287 151.707 491.48 394.785 224 387.814z&quot;/&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>现在，我们把精简后的 SVG 丢进 <a href="http://meyerweb.com/eric/tools/dencoder/" target="_blank" rel="external">URL</a> 编码器，会得到这样的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20d%3D%22M224%20387.814V512L32%20320l192-192v126.912C447.375%20260.152%20437.794%20103.016%20380.93%200%20521.287%20151.707%20491.48%20394.785%20224%20387.814z%22%2F%3E%3C%2Fsvg%3E</span><br></pre></td></tr></table></figure>
<p>目前这是唯一能在 IE 中工作的版本。非常明显，这甚至比 base64 编码过后的 SVG 都要长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBkPSJNMjI0IDM4Ny44MTRWNTEyTDMyIDMyMGwxOTItMTkydjEyNi45MTJDNDQ3LjM3NSAyNjAuMTUyIDQzNy43OTQgMTAzLjAxNiAzODAuOTMgMCA1MjEuMjg3IDE1MS43MDcgNDkxLjQ4IDM5NC43ODUgMjI0IDM4Ny44MTR6Ii8</span><br></pre></td></tr></table></figure>
<h2 id="“引号是关键”"><a href="#“引号是关键”" class="headerlink" title="“引号是关键”"></a>“引号是关键”</h2><p>你可能注意到了，Chris 使用单引号（<code>&#39;</code>）来界定 data URIs。这是因为他的 SVG 文件未编码时使用双引号（<code>&quot;</code>）来包裹属性值，为了避免冲突而使用了单引号来代替。这一点点微小的改变其实是真正精简 data URI 的关键。</p>
<p><code>&quot;</code> 和 <code>&#39;</code> 都是有效的属性分隔符（即：<code>attribute=&quot;value&quot;</code> 和 <code>attribute=&#39;value&#39;</code> 都有效），但是只有<code>&#39;</code>可以直接在 URL 中使用而无须编码转换。现在我们替换双引号，编码<code>&lt;</code>和<code>&gt;</code>，得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 512 512&apos;%3E%3Cpath d=&apos;M224 387.814V512L32 320l192-192v126.912C447.375 260.152 437.794 103.016 380.93 0 521.287 151.707 491.48 394.785 224 387.814z&apos;/%3E%3C/svg%3E</span><br></pre></td></tr></table></figure>
<p>所以，当你把 SVG 作为 data URI使用时：</p>
<p>用单引号替换包裹属性值的双引号<br>编码 <code>&lt;</code>，<code>&gt;</code>，<code>#</code>，和剩余的 <code>&quot;</code> （例如在文本内容中的双引号），以及其他一直的不安全 URL 字符（例如 <code>%</code>）<br>使用双引号来分隔 data URI（<code>&lt;img src=&quot;&quot;&gt;</code>，<code>url(&quot;&quot;)</code>）</p>
<p>网友 jakob-e 在 SASS 中实现了这个算法，使整个流程变得非常简单：</p>
<iframe scrolling="no" src="//codepen.io/jakob-e/embed/doMoML/?height=287&amp;theme-id=0&amp;default-tab=js" allowtransparency="true" allowfullscreen="true" style="width: 100%;" frameborder="no" height="287">See the Pen &lt;a href=’<a href="http://codepen.io/jakob-e/pen/doMoML/&#39;&gt;Encode" target="_blank" rel="external">http://codepen.io/jakob-e/pen/doMoML/&#39;&gt;Encode</a> SVG SCSS&lt;/a&gt; by jakob-e (&lt;a href=’<a href="http://codepen.io/jakob-e&#39;&gt;@jakob-e&lt;/a&amp;gt" target="_blank" rel="external">http://codepen.io/jakob-e&#39;&gt;@jakob-e&lt;/a&amp;gt</a>;) on &lt;a href=’<a href="http://codepen.io&#39;&gt;CodePen&lt;/a&amp;gt" target="_blank" rel="external">http://codepen.io&#39;&gt;CodePen&lt;/a&amp;gt</a>;.<br></iframe>

<p>以上就是如何得到能够在 IE （以及标准）中使用最精简的 data URI。总结一下：</p>
<p>base64 编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBkPSJNMjI0IDM4Ny44MTRWNTEyTDMyIDMyMGwxOTItMTkydjEyNi45MTJDNDQ3LjM3NSAyNjAuMTUyIDQzNy43OTQgMTAzLjAxNiAzODAuOTMgMCA1MjEuMjg3IDE1MS43MDcgNDkxLjQ4IDM5NC43ODUgMjI0IDM4Ny44MTR6Ii8+PC9zdmc+</span><br></pre></td></tr></table></figure>
<p>完全 URL 编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/svg+xml;charset=utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20d%3D%22M224%20387.814V512L32%20320l192-192v126.912C447.375%20260.152%20437.794%20103.016%20380.93%200%20521.287%20151.707%20491.48%20394.785%20224%20387.814z%22%2F%3E%3C%2Fsvg%3E</span><br></pre></td></tr></table></figure>
<p>最大程度优化的 URL 编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/svg+xml;charset=utf8,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 512 512&apos;%3E%3Cpath d=&apos;M224%20387.814V512L32 320l192-192v126.912C447.375 260.152 437.794 103.016 380.93 0 521.287 151.707 491.48 394.785 224 387.814z&apos;/%3E%3C/svg%3E</span><br></pre></td></tr></table></figure></p>
<p>我们测试发现，结果它在 IE9+ 以及 安卓3.x 以上的浏览器中都能够完美显示。</p>
<iframe scrolling="no" src="//codepen.io/Tigt/embed/wavYWE/?height=268&amp;theme-id=0&amp;default-tab=result" allowtransparency="true" allowfullscreen="true" style="width: 100%;" frameborder="no" height="268">See the Pen &lt;a href=’<a href="http://codepen.io/Tigt/pen/wavYWE/&#39;&gt;Cross-Browser" target="_blank" rel="external">http://codepen.io/Tigt/pen/wavYWE/&#39;&gt;Cross-Browser</a> data URI encoding test&lt;/a&gt; by Taylor Hunt (&lt;a href=’<a href="http://codepen.io/Tigt&#39;&gt;@Tigt&lt;/a&amp;gt" target="_blank" rel="external">http://codepen.io/Tigt&#39;&gt;@Tigt&lt;/a&amp;gt</a>;) on &lt;a href=’<a href="http://codepen.io&#39;&gt;CodePen&lt;/a&amp;gt" target="_blank" rel="external">http://codepen.io&#39;&gt;CodePen&lt;/a&amp;gt</a>;.<br></iframe>

<p>参考资料：</p>
<p><a href="http://codepen.io/Tigt/post/optimizing-svgs-in-data-uris" target="_blank" rel="external">Optimizing SVGs in data URIs</a></p>
<p><a href="https://css-tricks.com/probably-dont-base64-svg/" target="_blank" rel="external">Probably Don’t Base64 SVG</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SVG、dataURI、base64/">SVG、dataURI、base64</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-localstorage基本知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/15/localstorage基本知识/" class="article-date">
  	<time datetime="2016-12-15T08:56:21.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/localstorage基本知识/">localstorage基本知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTML5-LocalStorage-发展历程"><a href="#HTML5-LocalStorage-发展历程" class="headerlink" title="HTML5 LocalStorage 发展历程"></a>HTML5 LocalStorage 发展历程</h2><p>说到本地存储，这玩意真是历尽千辛万苦才走到HTML5这一步，之前的历史大概如下图所示：</p>
<p><img src="//img.pfan123.com/localstorage_1.jpg" alt="HTML5 LocalStorage发展历史"></p>
<p>最早的Cookies自然是大家都知道，问题主要就是太小，大概也就4KB的样子，而且IE6只支持每个域名20个cookies，太少了。优势就是大家都支持，而且支持得还蛮好。很早以前那些禁用cookies的用户也都慢慢的不存在了，就好像以前禁用javascript的用户不存在了一样。</p>
<p>到了HTML5把这些都统一了，官方建议是每个网站5MB，非常大了，就存些字符串，足够了。比较诡异的是居然所有支持的浏览器目前都采用的5MB，尽管有一些浏览器可以让用户设置，但对于网页制作者来说，目前的形势就5MB来考虑是比较妥当的。 </p>
<h2 id="HTML-本地存储API"><a href="#HTML-本地存储API" class="headerlink" title="HTML 本地存储API"></a>HTML 本地存储API</h2><p>localstorage在浏览器的API有两个：<code>localStorage</code>和<code>sessionStorage</code>，存在于window对象中：<code>localStorage</code>对应<code>window.localStorage</code>，<code>sessionStorage</code>对应<code>window.sessionStorage</code>。<br><code>localStorage</code>和<code>sessionStorage</code>的区别主要是在于其生存期。</p>
<h2 id="本地存储基本使用方法"><a href="#本地存储基本使用方法" class="headerlink" title="本地存储基本使用方法"></a>本地存储基本使用方法</h2><p>localStorage用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&quot;b&quot;,&quot;isaac&quot;);//设置b为&quot;isaac&quot;</span><br><span class="line">var b = localStorage.getItem(&quot;b&quot;);//获取b的值,为&quot;isaac&quot;</span><br><span class="line">var a = localStorage.key(0); // 获取第0个数据项的键名，此处即为“b”</span><br><span class="line">localStorage.removeItem(&quot;b&quot;);//清除c的值</span><br><span class="line">localStorage.clear();//清除当前域名下的所有localstorage数据</span><br></pre></td></tr></table></figure></p>
<p>sessionStorage用法（在当前页面才能生效，反之清楚存储）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(&quot;b&quot;,&quot;isaac&quot;);//设置b为&quot;isaac&quot;</span><br><span class="line">var b = sessionStorage.getItem(&quot;b&quot;);//获取b的值,为&quot;isaac&quot;</span><br><span class="line">var a = sessionStorage.key(0); // 获取第0个数据项的键名，此处即为“b”</span><br><span class="line">sessionStorage.removeItem(&quot;b&quot;);//清除c的值</span><br><span class="line">sessionStorage.clear();//清除当前域名下的所有localstorage数据</span><br></pre></td></tr></table></figure>
<h2 id="本地存储作用域"><a href="#本地存储作用域" class="headerlink" title="本地存储作用域"></a>本地存储作用域</h2><p><img src="//img.pfan123.com/localstorage_2.png" alt="HTML5 LocalStorage发展历史"></p>
<ul>
<li>这里的作用域指的是：如何隔离开不同页面之间的<code>localStorage</code>（总不能在百度的页面上能读到腾讯的<code>localStorage</code>吧，哈哈哈）。</li>
<li><code>localStorage</code>只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份<code>localStorage</code>数据。</li>
<li><code>sessionStorage</code>比<code>localStorage</code>更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。</li>
</ul>
<h2 id="本地存储生存期"><a href="#本地存储生存期" class="headerlink" title="本地存储生存期"></a>本地存储生存期</h2><p><code>localStorage</code>理论上来说是永久有效的，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。但需要注意的是，在移动设备上的浏览器或各<code>Native App</code>用到的<code>WebView</code>里，<code>localStorage</code>都是不可靠的，可能会因为各种原因（比如说退出App、网络切换、内存不足等原因）被清空。<br><code>sessionStorage</code>的生存期顾名思义，类似于<code>session</code>，只要关闭浏览器（也包括浏览器的标签页），就会被清空。由于<code>sessionStorage</code>的生存期太短，因此应用场景很有限，但从另一方面来看，不容易出现异常情况，比较可靠。</p>
<h2 id="本地存储的空间（SIZE）"><a href="#本地存储的空间（SIZE）" class="headerlink" title="本地存储的空间（SIZE）"></a>本地存储的空间（SIZE）</h2><p>各主流浏览器（包含PC、移动端）竟然惊人的一致，pc端为5M，移动的为2.5M。值得说明的是，安卓上手 Q 、手机QQ浏览器、微信中则是 2.5M 的数量级，因此在移动端，本地存储的 SIZE 更加珍贵。IOS 待测试。 综上，SIZE 在 2 - 5M 的区间。 测试页面：<a href="http://dev-test.nemikor.com/web-storage/support-test/" target="_blank" rel="external">Web Storage Support Test
</a></p>
<h3 id="超过最大值的行为"><a href="#超过最大值的行为" class="headerlink" title="超过最大值的行为"></a>超过最大值的行为</h3><ul>
<li>各浏览器也惊人的一致，都是抛出一个错误<code>QUOTA_EXCEEDED_ERR</code>。</li>
<li>在<code>firefox</code>以及<code>opera</code>中，用户可以自己设置本地存储的大小。</li>
</ul>
<p><img src="//img.pfan123.com/localstorage_3.png" alt="HTML5 LocalStorage发展历史"></p>
<h2 id="整站本地存储的规划"><a href="#整站本地存储的规划" class="headerlink" title="整站本地存储的规划"></a>整站本地存储的规划</h2><p>客户端的存储空间非常宝贵，然而站点也因为业务的不同，很难有一个统一的实施细则，但是有几个大原则不会变。</p>
<ul>
<li>只保存重要页面的重要数据<br>典型的，首页首屏<br>对业务庞大的站点，这点尤其重要</li>
<li>极大提高用户体验的数据<br>比如表单的状态，可以提交之前保存，当用户刷新页面时可以还原<br>静态资源，比如 js 和 css</li>
<li>一个请求一个 key 值（一个 cgi 一个 key 值）<br>避免请求链接加参数的 key (<a href="http://request-ajax.cgi[params])，这样必然让" target="_blank" rel="external">http://request-ajax.cgi[params])，这样必然让</a> key 值趋于冗余从而撑爆空间<br>以上几大原则仅作参考，一切从实际业务出发。</li>
</ul>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/xiaowei0705/archive/2011/04/19/2021372.html" target="_blank" rel="external">HTML5 LocalStorage 本地存储</a></p>
<p><a href="https://segmentfault.com/a/1190000004121465" target="_blank" rel="external">localstorage 必知必会</a></p>
<p><a href="http://imweb.io/topic/5590a443fbb23aae3d5e450a" target="_blank" rel="external">使用localStorage必须了解的点</a>  </p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML5、localstorage、sessionStorage/">HTML5、localstorage、sessionStorage</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-解析HTML:XML生成文档对象模型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/08/解析HTML:XML生成文档对象模型/" class="article-date">
  	<time datetime="2016-12-08T08:56:21.000Z" itemprop="datePublished">2016-12-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/08/解析HTML:XML生成文档对象模型/">解析HTML/XML生成文档对象模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间研究svg压缩处理优化，针对文本html、xml文件解析成DOM文档对象，一直困扰着我。那么，今天讲讲借助<a href="https://github.com/fb55/htmlparser2" target="_blank" rel="external">htmlparser2</a>、<a href="https://github.com/isaacs/sax-js" target="_blank" rel="external">sax-js</a>、<a href="https://github.com/jindw/xmldom" target="_blank" rel="external">xmldom</a> 解析HTML/XML。</p>
<h2 id="htmlparser2"><a href="#htmlparser2" class="headerlink" title="htmlparser2"></a>htmlparser2</h2><p>htmlparser2可以用来处理HTML / XML / RSS的解析器，可以接收流文件，并提供回调接口。<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">cheerio</a>底层就是用此原理。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p><a href="http://demos.forbeslindesay.co.uk/htmlparser2/" target="_blank" rel="external">htmlparser2线上解析演示</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install htmlparser2</span><br></pre></td></tr></table></figure>
<h3 id="使用todo"><a href="#使用todo" class="headerlink" title="使用todo"></a>使用todo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//解析</span><br><span class="line">var htmlparser = require(&quot;htmlparser2&quot;);</span><br><span class="line">var parser = new htmlparser.Parser(&#123;</span><br><span class="line">    onopentag: function(name, attribs)&#123;</span><br><span class="line">        if(name === &quot;script&quot; &amp;&amp; attribs.type === &quot;text/javascript&quot;)&#123;</span><br><span class="line">            console.log(&quot;JS! Hooray!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ontext: function(text)&#123;</span><br><span class="line">        console.log(&quot;--&gt;&quot;, text);</span><br><span class="line">    &#125;,</span><br><span class="line">    onclosetag: function(tagname)&#123;</span><br><span class="line">        if(tagname === &quot;script&quot;)&#123;</span><br><span class="line">            console.log(&quot;That&apos;s it?!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;decodeEntities: true&#125;);</span><br><span class="line">parser.write(&quot;Xyz &lt;script type=&apos;text/javascript&apos;&gt;var foo = &apos;&lt;&lt;bar&gt;&gt;&apos;;&lt;/ script&gt;&quot;);</span><br><span class="line">parser.end();</span><br><span class="line"></span><br><span class="line">//生成简单的文档对象</span><br><span class="line">var htmlparser = require(&quot;htmlparser2&quot;);</span><br><span class="line">var rawHtml = &quot;Xyz &lt;script language= javascript&gt;var foo = &apos;&lt;&lt;bar&gt;&gt;&apos;;&lt; /  script&gt;&lt;!--&lt;!-- Waah! -- --&gt;&quot;;</span><br><span class="line">var handler = new htmlparser.DomHandler(function (error, dom) &#123;</span><br><span class="line">    if (error)&#123;</span><br><span class="line">    	throw new error()</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    	console.log(dom);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;);</span><br><span class="line">var parser = new htmlparser.Parser(handler);</span><br><span class="line">parser.write(rawHtml);</span><br><span class="line">parser.done();</span><br></pre></td></tr></table></figure>
<h3 id="htmlparser2监听事件Events"><a href="#htmlparser2监听事件Events" class="headerlink" title="htmlparser2监听事件Events"></a>htmlparser2监听事件Events</h3><p>监听处理键值对象函数，仅对有效的键值进行处理，否则中断。</p>
<ul>
<li>onopentag(<str> name, <obj> attributes)  </obj></str></li>
<li>onopentagname(<str> name)</str></li>
<li>onattribute(<str> name, <str> value)</str></str></li>
<li>ontext(<str> text)</str></li>
<li>onclosetag(<str> name)</str></li>
<li>onprocessinginstruction(<str> name, <str> data)</str></str></li>
<li>oncomment(<str> data)</str></li>
<li>oncommentend()</li>
<li>oncdatastart()</li>
<li>oncdataend()</li>
<li>onerror(<err> error)</err></li>
<li>onreset()</li>
<li>onend()</li>
</ul>
<h3 id="htmlparser2解析方法"><a href="#htmlparser2解析方法" class="headerlink" title="htmlparser2解析方法"></a>htmlparser2解析方法</h3><ul>
<li>write (别名: parseChunk)</li>
</ul>
<p>解析数据块，触发相应的回调函数</p>
<ul>
<li>end (别名: done)</li>
</ul>
<p>解析buffer数据和清除堆栈结束，触发 onend 回调函数。</p>
<ul>
<li>reset</li>
</ul>
<p>重置buffer以及stack，触发 onreset 函数</p>
<ul>
<li>parseComplete</li>
</ul>
<p>重置解析器解析数据，触发调用 end。</p>
<h3 id="htmlparser2参数-Option"><a href="#htmlparser2参数-Option" class="headerlink" title="htmlparser2参数 Option"></a>htmlparser2参数 Option</h3><ul>
<li>Option: xmlMode</li>
</ul>
<p>表示是否是特殊标签<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>应该得到特殊处理, 如果是空”empty” 的标签（如&lt; br &gt;）含有子元素。如果没有特殊处理，则特殊标签将做文本处理。<br>解析其它XML内容(不包含HTML文件), 设置为true。默认值:false。</p>
<ul>
<li>Option: decodeEntities</li>
</ul>
<p>设置为true，文档中内容实体部分将解码。默认值为false。</p>
<ul>
<li>Option: lowerCaseTags</li>
</ul>
<p>设置为true，所有标签将小写展示。xmlMode不设置情况下，默认值为true。</p>
<ul>
<li>Option: lowerCaseAttributeNames</li>
</ul>
<p>设置为true，所以属性name将设置为小写。由于影响解析速度，默认值为false。</p>
<ul>
<li>Option: recognizeCDATA</li>
</ul>
<p>设置为true，CDATA区域将被认为文本，即使xmlMode选项不启用。注意，xmlMode被设置为true,那么CDATA节总是会被认为是文本。</p>
<ul>
<li>Option: recognizeSelfClosing</li>
</ul>
<p>设置为true，其关闭标签将触发 onclosetag 事件即使xmlMode没有设置为true。注意: xmlMode设置为true,那么自闭标签总是被认可。</p>
<blockquote>
<p>htmlparser2主要是提供了对HTML / XML / RSS的解析，效率比较高，而相应生成简单的文档对象，需要借助<a href="https://github.com/fb55/domhandler" target="_blank" rel="external">domhandler</a>模块，只是增加了DOM level 1不便于操作。</p>
</blockquote>
<h2 id="sax-js"><a href="#sax-js" class="headerlink" title="sax-js"></a>sax-js</h2><p>sax-style风格处理XML和HTML的解析器，<a href="https://github.com/isaacs/sax-js" target="_blank" rel="external">sax js</a>。</p>
<h3 id="安装使用-1"><a href="#安装使用-1" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sax-js</span><br></pre></td></tr></table></figure>
<h3 id="使用todo-1"><a href="#使用todo-1" class="headerlink" title="使用todo"></a>使用todo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var sax = require(&quot;./lib/sax&quot;),</span><br><span class="line">  strict = true, // set to false for html-mode</span><br><span class="line">  parser = sax.parser(strict);</span><br><span class="line"></span><br><span class="line">parser.onerror = function (e) &#123;</span><br><span class="line">  // an error happened.</span><br><span class="line">&#125;;</span><br><span class="line">parser.ontext = function (t) &#123;</span><br><span class="line">  // got some text.  t is the string of text.</span><br><span class="line">&#125;;</span><br><span class="line">parser.onopentag = function (node) &#123;</span><br><span class="line">  // opened a tag.  node has &quot;name&quot; and &quot;attributes&quot;</span><br><span class="line">&#125;;</span><br><span class="line">parser.onattribute = function (attr) &#123;</span><br><span class="line">  // an attribute.  attr has &quot;name&quot; and &quot;value&quot;</span><br><span class="line">&#125;;</span><br><span class="line">parser.onend = function () &#123;</span><br><span class="line">  // parser stream is done, and ready to have more stuff written to it.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parser.write(&apos;&lt;xml&gt;Hello, &lt;who name=&quot;world&quot;&gt;world&lt;/who&gt;!&lt;/xml&gt;&apos;).close();</span><br><span class="line"></span><br><span class="line">// stream usage</span><br><span class="line">// takes the same options as the parser</span><br><span class="line">var saxStream = require(&quot;sax&quot;).createStream(strict, options)</span><br><span class="line">saxStream.on(&quot;error&quot;, function (e) &#123;</span><br><span class="line">  // unhandled errors will throw, since this is a proper node</span><br><span class="line">  // event emitter.</span><br><span class="line">  console.error(&quot;error!&quot;, e)</span><br><span class="line">  // clear the error</span><br><span class="line">  this._parser.error = null</span><br><span class="line">  this._parser.resume()</span><br><span class="line">&#125;)</span><br><span class="line">saxStream.on(&quot;opentag&quot;, function (node) &#123;</span><br><span class="line">  // same object as above</span><br><span class="line">&#125;)</span><br><span class="line">// pipe is supported, and it&apos;s readable/writable</span><br><span class="line">// same chunks coming in also go out.</span><br><span class="line">fs.createReadStream(&quot;file.xml&quot;)</span><br><span class="line">  .pipe(saxStream)</span><br><span class="line">  .pipe(fs.createWriteStream(&quot;file-copy.xml&quot;))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于sax-js解析的许多方法基本与htmlparser2一致，只是解析效率上比htmlparser2稍差。</p>
</blockquote>
<h2 id="XMLDOM"><a href="#XMLDOM" class="headerlink" title="XMLDOM"></a>XMLDOM</h2><p><a href="https://github.com/jindw/xmldom" target="_blank" rel="external">XMLDOM</a>是一款非常强大的解析工具，可实现浏览使用的 javascript文档对象模型 (W3C DOM) 。完美兼容DOM Level 2 以及部分 DOM Level 3。支持支持DOMParser和XMLSerializer接口浏览。解析为文档对象</p>
<p>参考资料:<br><a href="http://www.w3cplus.com/svg/svg-tips-for-designers.html" target="_blank" rel="external">创建和导出SVG的技巧</a><br><a href="https://ashung.github.io/stories/svg-export.html" target="_blank" rel="external">SVG 导出与优化</a></p>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p>npm install xmldom</p>
<h3 id="使用todo-2"><a href="#使用todo-2" class="headerlink" title="使用todo"></a>使用todo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var DOMParser = require(&apos;xmldom&apos;).DOMParser;</span><br><span class="line">var doc = new DOMParser().parseFromString(</span><br><span class="line">    &apos;&lt;xml xmlns=&quot;a&quot; xmlns:c=&quot;./lite&quot;&gt;\n&apos;+</span><br><span class="line">        &apos;\t&lt;child&gt;test&lt;/child&gt;\n&apos;+</span><br><span class="line">        &apos;\t&lt;child&gt;&lt;/child&gt;\n&apos;+</span><br><span class="line">        &apos;\t&lt;child/&gt;\n&apos;+</span><br><span class="line">    &apos;&lt;/xml&gt;&apos;</span><br><span class="line">    ,&apos;text/xml&apos;);</span><br><span class="line">//doc相当于document，doc.documentElement相当于document.documentElement</span><br><span class="line">doc.documentElement.setAttribute(&apos;x&apos;,&apos;y&apos;);</span><br><span class="line">doc.documentElement.setAttributeNS(&apos;./lite&apos;,&apos;c:x&apos;,&apos;y2&apos;);</span><br><span class="line">var nsAttr = doc.documentElement.getAttributeNS(&apos;./lite&apos;,&apos;x&apos;)</span><br><span class="line">console.info(nsAttr)</span><br><span class="line">console.info(doc)</span><br></pre></td></tr></table></figure>
<h3 id="API特征"><a href="#API特征" class="headerlink" title="API特征"></a>API特征</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMParser" target="_blank" rel="external">DOMParser</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFromString(xmlsource,mimeType)</span><br></pre></td></tr></table></figure>
<p>options extension by xmldom(not BOM standard!!)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//added the options argument</span><br><span class="line">new DOMParser(options)</span><br><span class="line"></span><br><span class="line">//errorHandler is supported</span><br><span class="line">new DOMParser(&#123;</span><br><span class="line">    /**</span><br><span class="line">     * locator is always need for error position info</span><br><span class="line">     */</span><br><span class="line">    locator:&#123;&#125;,</span><br><span class="line">    /**</span><br><span class="line">     * you can override the errorHandler for xml parser</span><br><span class="line">     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html</span><br><span class="line">     */</span><br><span class="line">    errorHandler:&#123;warning:function(w)&#123;console.warn(w)&#125;,error:callback,fatalError:callback&#125;</span><br><span class="line">    //only callback model</span><br><span class="line">    //errorHandler:function(level,msg)&#123;console.log(level,msg)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer" target="_blank" rel="external">XMLSerializer 可以将DOM subtree 和 DOM document转换为文本</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializeToString(node)</span><br></pre></td></tr></table></figure>
<h3 id="DOM-level2-方法-method-和-属性-attribute"><a href="#DOM-level2-方法-method-和-属性-attribute" class="headerlink" title="DOM level2 方法(method) 和 属性(attribute):"></a>DOM level2 方法(method) 和 属性(attribute):</h3><ul>
<li><a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247" target="_blank" rel="external">Node</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">attribute:</span><br><span class="line">    nodeValue|prefix</span><br><span class="line">readonly attribute:</span><br><span class="line">    nodeName|nodeType|parentNode|childNodes|firstChild|lastChild|previousSibling|nextSibling|attributes|ownerDocument|namespaceURI|localName</span><br><span class="line">method: </span><br><span class="line">    insertBefore(newChild, refChild)</span><br><span class="line">    replaceChild(newChild, oldChild)</span><br><span class="line">    removeChild(oldChild)</span><br><span class="line">    appendChild(newChild)</span><br><span class="line">    hasChildNodes()</span><br><span class="line">    cloneNode(deep)</span><br><span class="line">    normalize()</span><br><span class="line">    isSupported(feature, version)</span><br><span class="line">    hasAttributes()</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-102161490" target="_blank" rel="external">DOMImplementation</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method:</span><br><span class="line">    hasFeature(feature, version)</span><br><span class="line">    createDocumentType(qualifiedName, publicId, systemId)</span><br><span class="line">    createDocument(namespaceURI, qualifiedName, doctype)</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="https://github.com/fb55/domhandler" target="_blank" rel="external">domhandler</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMParser" target="_blank" rel="external">DOMParser</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer" target="_blank" rel="external">XMLSerializer 可以将DOM subtree 和 DOM document转换为文本</a>  </p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML、XML解析、dom-level、htmlparser2、xmldom、sax-js、cheerio/">HTML、XML解析、dom level、htmlparser2、xmldom、sax-js、cheerio</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-SVG 导出与优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/03/SVG 导出与优化/" class="article-date">
  	<time datetime="2016-12-03T08:56:21.000Z" itemprop="datePublished">2016-12-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/03/SVG 导出与优化/">SVG 导出与优化（转载）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="使用-Illustrator-导出-SVG"><a href="#使用-Illustrator-导出-SVG" class="headerlink" title="使用 Illustrator 导出 SVG"></a>使用 Illustrator 导出 SVG</h2><p>Illustrator 是目前相对较好的 SVG 设计工具，在 Illustrator 中另存为 SVG 是较常用的导出 SVG 方法，具体如何操作网上有很多资料。如果你熟悉 Illustrator 或者决定使用 Illustrator 绘制图标，你可以从查看官方帮助文档<a href="https://helpx.adobe.com/cn/illustrator/using/saving-artwork.html" target="_blank" rel="external">存储图稿-以 SVG 格式存储</a>，或者 <a href="http://create.adobe.com/2015/11/9/inspire_is_now_adobe_create_magazine.html" target="_blank" rel="external">Exporting SVG for the web with Adobe Illustrator CC</a>。也可以看看 <a href="https://sarasoueidan.com/" target="_blank" rel="external">Sara Soueidan</a> 在她的文章 <a href="https://sarasoueidan.com/blog/svg-tips-for-designers/" target="_blank" rel="external">Tips for Creating and Exporting Better SVGs for the Web</a> 中介绍的一些 Illustrator 关于创建和导出 SVG 的技巧。</p>
<p>另外在 Illustrator 上直接复制选中内容，粘贴至文本编辑器，也可以得到选中内容的 SVG 代码。我在做网页用的 SVG 时就经常这么做，画个矩形作为图标的边界，把图标连同矩形一起复制，然后在粘贴到文本编辑器里，再删除矩形的代码。但这对设计师来说较复杂了，也不适合批量操作，此外这种方法无法控制路径数据的精度。</p>
<p>还有一种方法是使用 Illustrator 画板导出 SVG，画板大小做为图标切图区域，在另存为 SVG 时选择导出多个画板，建议画布命名为资源文件名。Illustrator 中增加新画板对新手来说经常会忽视不齐像素，我用一个脚本把选中的图层转为画板并且自动对齐像素，最后用再另外一个脚本导出画板。如果图标很多，因为画板最多只能支持 100 个，这种方法还是有一些局限。你可以下载 <a href="https://github.com/Ashung/GUI_Automation_Toolbox/blob/master/Illustrator_Scripts/Artboards_To_SVG.jsx" target="_blank" rel="external">Selection_to_Artboard.jsx</a> (用于将选择图层转为画板) 和 <a href="https://github.com/Ashung/GUI_Automation_Toolbox/blob/master/Illustrator_Scripts/Selection_to_Artboard.jsx" target="_blank" rel="external">Artboards_To_SVG.jsx</a> (用于将画板导出为 SVG) 这两个脚本，它们仅适用于较小项目。</p>
<p>当项目较大时推荐使用 <a href="https://github.com/iconic/illustrator-svg-exporter" target="_blank" rel="external">Illustrator SVG Exporter</a>，这是一个只有选择保存路径对话框的 Illustrator 脚本，用于导出文档中带 “.svg” 后缀的路径、复合路径、组合、图层、画板等等，具体操作可见 <a href="https://github.com/iconic/illustrator-svg-exporter" target="_blank" rel="external">Illustrator SVG Exporter</a> 的项目主页。Illustrator SVG Exporter 导出的 SVG 是沿着内容边界裁切的，所以需要在组合或图层内包含一个矩形作为切图边界，这个矩形可以是无填充的路径，最后再统一去掉这个作为切图区域矩形的代码。</p>
<p><img src="//img.pfan123.com/screenshot_ai1.png" alt="svg优化"></p>
<p><a href="https://github.com/google/material-design-icons/" target="_blank" rel="external">Material design icons</a> 的 SVG 也带有多余的矩形的，应该是类似的导出方法。当图标数量巨大时，需要使用编程的方法来删除 SVG 文件内作为切图区域矩形的多余代码，除非团队里有很多人手，否则人工操作几乎不可能。Google 并没公布他们用的处理脚本。对代码恐惧，连运行代码都有难度的设计师而言，确实是很大挑战。选用画板导出方式则不需要处理这种问题，下文会介绍批量删除多余代码的方法。</p>
<p>Illustrator SVG Exporter 默认导出的 SVG 路径数据是精确到 4 位小数的，对于界面使用的小图标并不需要这么精确，可以通过修改源码，将精确度改为 1 或 2 位小数。代码大概在 41 行位置，找到svgOptions.coordinatePrecision = 4，将数值改为1或2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svgOptions.coordinatePrecision = 1;</span><br></pre></td></tr></table></figure>
<p>David Deraedt 的 <a href="https://github.com/davidderaedt/Illustrator-Layer-Exporter" target="_blank" rel="external">Layer Exporter</a> 是个拥有类似功能的 Illustrator 扩展，除了导出 SVG 外，还支持 PNG、JPG 格式，另外还提供一些简单的设置，具体使用方法可以查阅项目主页文档。</p>
<p>注意事项</p>
<ul>
<li>尽量把路径描边需要扩展为填充，除非确定需要使用描边的特性。</li>
<li>对于同一个图标，或者图标内同类元素尽量组合成复合路径或合并路径。</li>
<li>合理的编组或者图层，一个项目内的设计内容要么是按编组划分的，要么按图层划分，不要混用两种方式。</li>
<li>注意画板的坐标、路径节点的坐标尽量是整数。</li>
<li>不要用 Illustrator 打开 SVG 文件修改再保存，这样经常会导致保存后的 SVG 代码中 viewport、path 标签的数值偏移。</li>
</ul>
<h2 id="Photoshop-中使用-Generate-导出-SVG"><a href="#Photoshop-中使用-Generate-导出-SVG" class="headerlink" title="Photoshop 中使用 Generate 导出 SVG"></a>Photoshop 中使用 Generate 导出 SVG</h2><p>在 Photoshop CC 2015 可以使用画板导出 SVG，将画板大小作为切图区域，这样可以不需要额外图层作为边界。</p>
<p><img src="//img.pfan123.com/screenshot_ai2.png" alt="svg优化"></p>
<p>注意事项</p>
<ul>
<li>尽量把路径描边需要扩展为填充，除非确定需要使用描边的特性。</li>
<li>对于同一个图标，或者图标内同类元素尽量放在同一个矢量图层内。</li>
<li>因为 Photoshop 没有矢量预览功能，所以尽量注意路径结合处的细节。</li>
<li>Photoshop 导出的 SVG 代码不可设置，而且 SVG 代码中元素属性被分离成 CSS 样式。</li>
</ul>
<h2 id="Sketch-导出-SVG"><a href="#Sketch-导出-SVG" class="headerlink" title="Sketch 导出 SVG"></a>Sketch 导出 SVG</h2><p>如果使用 Sketch 导出 SVG 建议通过切片方式，并且切片不要包含在画板内(这张情况会导致 SVG 路径的数据是安装画板坐标生成的)。如果使用可导出图层就需要增加矩形图层作为切图边界，该图层不可以设置为无填充或者不可见，建议填充一个固定的色值。Sketch 的优点是导出不需要借助复制的脚本或插件。</p>
<p><img src="//img.pfan123.com/screenshot_ai3.png" alt="svg优化"></p>
<p>Sketch 导出的 SVG 代码冗余比较多且无法设置，而且经常增加一些奇怪的行为，如果画布中只有一个图层，Sketch 会将路径的数据加在路径父级的标签上。Github 上有一些清理 Sketch SVG 代码的工具，都没有界面的，对设计师来说又是挑战。</p>
<p>Github 上有一些清理 Sketch SVG 代码的工具，都是命令行工具或某个编程语言的模块/包，而不是 Sketch 插件。以下列出几个排名较高的清理工具。</p>
<ul>
<li><a href="https://github.com/overblog/clean-sketch" target="_blank" rel="external">clean-sketch</a>，Node.js 模块。</li>
<li><a href="https://github.com/overblog/gulp-clean-sketch" target="_blank" rel="external">gulp-clean-sketch</a> ，clean-sketch 的 gulp 插件。</li>
<li><a href="https://github.com/Warry/SketchCleaner" target="_blank" rel="external">Sketch SVG cleaner</a>， Node.js 命令行工具。</li>
<li><a href="https://github.com/aj0strow/clean-sketch-svg" target="_blank" rel="external">clean-sketch-svg</a>， Ruby 命令行工具。</li>
</ul>
<p>SVG 代码优化</p>
<p>设计软件导出的 SVG 都包含各种多余的代码，这会导致文件体积较大，一般最终使用的 SVG 都会对 SVG 进行优化处理。</p>
<p>常用的 SVG 代码优化工具 <a href="https://github.com/svg/svgo" target="_blank" rel="external">SVG Optimizer</a> (简称 SVGO) 是一个 Node.js 命令行工具。也就是说这是没有界面的，要在终端上敲代码来优化 SVG，这是非常高效处理方法，但对不熟悉命令行工具的设计师来说可能会有难度。熟悉命令行工具之后，会使用发现大部分界面工具的效率并不高，建议设计师最好花点时间熟悉下命令行工具操作方式。</p>
<p><a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="external">svgomg</a> 是 SVGO 的 Node.js 网页应用，有很多设置项，但每次只能优化一个 SVG 文件，如果网页速度太慢，可以下载源码后在本地搭建。</p>
<p><a href="https://github.com/svg/svgo-gui" target="_blank" rel="external">svgo-gui</a> 是 SVGO 的跨平台界面工具，但目前已不维护，官方推荐使用命令行或网页版本。</p>
<p>SVGO 相关的工具还有 Node.js 模块版本的<a href="https://github.com/imagemin/imagemin-svgo" target="_blank" rel="external">imagemin-svgo</a>，gulp 插件版本的<a href="https://github.com/ben-eb/gulp-svgmin" target="_blank" rel="external">gulp-svgmin</a>，项目主页上都有示例代码。</p>
<p><a href="https://github.com/RazrFalcon/SVGCleaner" target="_blank" rel="external">SVGCleaner</a> 另一个跨平台的带 GUI 界面的 SVG 优化软件，对命令行不熟悉的设计师可以选择这个软件。</p>
<p>参考资料:<br><a href="http://www.w3cplus.com/svg/svg-tips-for-designers.html" target="_blank" rel="external">创建和导出SVG的技巧</a><br><a href="https://ashung.github.io/stories/svg-export.html" target="_blank" rel="external">SVG 导出与优化</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SVG-icon、-导出优化/">SVG icon、 导出优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-移动端音频解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/01/移动端音频解决方案/" class="article-date">
  	<time datetime="2016-12-01T08:56:21.000Z" itemprop="datePublished">2016-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/01/移动端音频解决方案/">移动端H5音频解决方案</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="音频传输原理"><a href="#音频传输原理" class="headerlink" title="音频传输原理"></a>音频传输原理</h2><p>目前音频在互联网上的传输基于流媒体技术, 音频是流媒体的一种, 称其为流媒体是一种形象的比喻, 将数据的传输比作水流, “流”的重要作用体现在可以明显的节省时间, 实现边下载边播放, 而不需要下载完成后才进行播放。</p>
<ul>
<li>缓存</li>
</ul>
<p>流媒体的传输需要缓存, 因为Internet是一个分组交换网, 在其上面传输文件数据都要拆分成一个个数据包, 最后在接收端进行组装, 由于网络是动态变化的, 各个数据包选择的路由可能不尽相同, 故到达客户端的时间延迟也就不等, 先发的数据后到也是常有的事. 因此, 使用缓存来保证到达的数据包进行正确的排序, 从而使媒体数据能连续输出.</p>
<p>之前提到的边下边播, 也是在缓存中接收到足够的数据时才能进行播放的, 这一点在HTML5的文档中也有所体现.</p>
<p>[ 题外话: HTML5 media 文档中, 提到了两个事件 ‘canplay’ 和 ‘canplaythrough’. ‘canplay’: ‘表示浏览器已经加载了足够的数据去播放媒体文件, 但预计以后的播放可能会产生停顿去加载新的数据’ ‘canplaythrough’: ‘表示浏览器已经加载了足够的数据去播放媒体文件并且预计在播放中不会产生停顿去加载新的数据’ ]</p>
<ul>
<li>UDP<br>流媒体传输的实现需要合适的传输协议. 由于TCP需要较多的开销, 因此不太适合传输实时数据. 在流媒体传输的实现方案中一般采用HTTP/TCP来传输控制信息, 使用RTP/UDP来传输实时声音数据。</li>
</ul>
<h2 id="目前可使用的技术"><a href="#目前可使用的技术" class="headerlink" title="目前可使用的技术"></a>目前可使用的技术</h2><ul>
<li>Web Audio API<br>Web Auido API 是 JavaScript 中用于在网页应用中处理音频的一个高级应该用接口, 主要用于实现Web端的音频处理, 并可以同已存在的其他API相配合, 包括XMLHttpRequest, Canvas 2D 和 WebGL 3D API.</li>
</ul>
<p>其支持的功能包括</p>
<blockquote>
<p>支持各种类型的音频滤波器以实现各种音频效果, 包括回声, 消除噪音等<br>支持利用合成声音 (Sound synthesis) 创建电子音乐<br>支持3D位置音频模拟效果, 比如某种声音随着游戏场景而移动 (3D游戏中应该用处比较大…)<br>支持外部输入的声音与 WebRTC 进行集成<br>以及各种高端音频处理方法…</p>
</blockquote>
<p>但是…</p>
<p>由于移动端对其支持不是很完善 [ iOS已支持, 安卓原生浏览器目前还不支持 ], 目前还是使用支持广泛的 HTML5 Audio 好一些</p>
<p><img src="//7xrig5.com1.z0.glb.clouddn.com/web_audio_support-1.jpg" alt="Web Audio"></p>
<ul>
<li>HTML5 Audio 标签</li>
</ul>
<p>Audio 标签是 HTML5 新定义的一个元素, 提供了在 Web 端播放音频的很多功能. 虽然没有 Web Audio API 那么强大, 但足以满足日常音频播放需求, 更重要的是使浏览器原生支持音频播放, 而不依赖 Flash 或 Sliverlight 之类的外部插件。</p>
<p><img src="//7xrig5.com1.z0.glb.clouddn.com/audio_tag.jpg" alt="HTML5 Audio"></p>
<p>参考资料:<br><a href="http://goldfirestudios.com/blog/104/howler.js-Modern-Web-Audio-Javascript-Library" target="_blank" rel="external">howler.js</a><br><a href="https://github.com/goldfire/howler.js/" target="_blank" rel="external">howler.js github库</a><br><a href="https://www.awesomes.cn/repo/goldfire/howler-js" target="_blank" rel="external">howler.js中文介绍</a><br><a href="https://github.com/CreateJS/SoundJS" target="_blank" rel="external">SoundJS</a><br><a href="https://github.com/wangjx9110/document/blob/master/audio_summary.md" target="_blank" rel="external">移动端音频解决方案</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/howler-js、-video-js/">howler.js、 video.js</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-HTTP 代理原理及实现（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/25/HTTP 代理原理及实现（二）/" class="article-date">
  	<time datetime="2016-11-25T08:56:21.000Z" itemprop="datePublished">2016-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/25/HTTP 代理原理及实现（二）/">HTTP 代理原理及实现（二）转载</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上篇《<a href="http://blog.pfan123.com/2016/11/25/HTTP%20%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">HTTP 代理原理及实现（一）</a>》里，我介绍了 HTTP 代理的两种形式，并用 Node.js 实现了一个可用的普通 / 隧道代理。普通代理可以用来承载 HTTP 流量；隧道代理可以用来承载任何 TCP 流量，包括 HTTP 和 HTTPS。今天这篇文章介绍剩余部分：如何将浏览器与代理之间的流量传输升级为 HTTPS。</p>
<p>上篇文章中实现的代理，是一个标准的 HTTP 服务，针对浏览器的普通请求和 CONNECT 请求，进行不同的处理。Node.js 为创建 HTTP 或 HTTPS Server 提供了高度一致的接口，要将 HTTP 服务升级为 HTTPS 特别方便，只有一点点准备工作要做。</p>
<p>我们知道 TLS 有三大功能：内容加密、身份认证和数据完整性。其中内容加密依赖于密钥协商机制；数据完整性依赖于 MAC（Message authentication code）校验机制；而身份认证则依赖于证书认证机制。一般操作系统或浏览器会维护一个受信任根证书列表，包含在列表之中的证书，或者由列表中的证书签发的证书都会被客户端信任。</p>
<p>提供 HTTPS 服务的证书可以自己生成，然后手动加入到系统根证书列表中。但是对外提供服务的 HTTPS 网站，不可能要求每个用户都手动导入你的证书，所以更常见的做法是向 CA（Certificate Authority，证书颁发机构）申请。根据证书的不同级别，CA 会进行不同级别的验证，验证通过后 CA 会用他们的证书签发网站证书，这个过程通常是收费的（有免费的证书，最近免费的 Let’s Encrypt 也很火，这里不多介绍）。由于 CA 使用的证书都是由广泛内置在各系统中的根证书签发，所以从 CA 获得的网站证书会被绝大部分客户端信任。</p>
<p>通过 CA 申请证书很简单，本文为了方便演示，采用自己签发证书的偷懒办法。现在广泛使用的证书是 x509.v3 格式，使用以下命令可以创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private.pem 2048</span><br><span class="line">openssl req -new -x509 -key private.pem -out public.crt -days 99999</span><br></pre></td></tr></table></figure>
<p>第二行命令运行后，需要填写一些证书信息。需要注意的是<code>Common Name</code> 一定要填写后续提供<code>HTTPS</code>服务的域名或 IP。例如你打算在本地测试，<code>Common Name</code>可以填写<code>127.0.0.1</code>。证书创建好之后，再将<code>public.crt</code> 添加到系统受信任根证书列表中。为了确保添加成功，可以用浏览器验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![HTTP 代理](//st.imququ.com/i/webp/static/uploads/2015/11/fake_certificate.png.webp)</span><br></pre></td></tr></table></figure>
<p>接着，可以改造之前的 Node.js 代码了，需要改动的地方不多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var https = require(&apos;https&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">function request(cReq, cRes) &#123;</span><br><span class="line">    var u = url.parse(cReq.url);</span><br><span class="line"></span><br><span class="line">    var options = &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || 80,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method     : cReq.method,</span><br><span class="line">        headers     : cReq.headers</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var pReq = http.request(options, function(pRes) &#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function connect(cReq, cSock) &#123;</span><br><span class="line">    var u = url.parse(&apos;http://&apos; + cReq.url);</span><br><span class="line"></span><br><span class="line">    var pSock = net.connect(u.port, u.hostname, function() &#123;</span><br><span class="line">        cSock.write(&apos;HTTP/1.1 200 Connection Established\r\n\r\n&apos;);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    key: fs.readFileSync(&apos;./private.pem&apos;),</span><br><span class="line">    cert: fs.readFileSync(&apos;./public.crt&apos;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">https.createServer(options)</span><br><span class="line">    .on(&apos;request&apos;, request)</span><br><span class="line">    .on(&apos;connect&apos;, connect)</span><br><span class="line">    .listen(8888, &apos;0.0.0.0&apos;);</span><br></pre></td></tr></table></figure>
<p>可以看到，除了将<code>http.createServer</code>换成 <code>https.createServer</code>，增加证书相关配置之外，这段代码没有任何改变。这也是引入 TLS 层的妙处，应用层不需要任何改动，就能获得诸多安全特性。</p>
<p>运行服务后，只需要将浏览器的代理设置为<code>HTTPS 127.0.0.1:8888</code>即可，功能照旧。这样改造，只是将浏览器到代理之间的流量升级为了 HTTPS，代理自身逻辑、与服务端的通讯方式，都没有任何变化。</p>
<p>最后，还是写段 Node.js 代码验证下这个 HTTPS 代理服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var https = require(&apos;https&apos;);</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    hostname : &apos;127.0.0.1&apos;,</span><br><span class="line">    port     : 8888,</span><br><span class="line">    path     : &apos;imququ.com:80&apos;,</span><br><span class="line">    method     : &apos;CONNECT&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//禁用证书验证，不然自签名的证书无法建立 TLS 连接</span><br><span class="line">process.env.NODE_TLS_REJECT_UNAUTHORIZED = &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">var req = https.request(options);</span><br><span class="line"></span><br><span class="line">req.on(&apos;connect&apos;, function(res, socket) &#123;</span><br><span class="line">    socket.write(&apos;GET / HTTP/1.1\r\n&apos; +</span><br><span class="line">                 &apos;Host: imququ.com\r\n&apos; +</span><br><span class="line">                 &apos;Connection: Close\r\n&apos; +</span><br><span class="line">                 &apos;\r\n&apos;);</span><br><span class="line"></span><br><span class="line">    socket.on(&apos;data&apos;, function(chunk) &#123;</span><br><span class="line">        console.log(chunk.toString());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    socket.on(&apos;end&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;socket end.&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure></p>
<p>这段代码和上篇文章最后那段的区别只是<code>http.request</code>换成了<code>https.request</code>，运行结果完全一样，这里就不贴了。本文所有代码可以从这个仓库获得：<a href="https://github.com/qgy18/proxy-demo" target="_blank" rel="external">proxy-demo</a>。</p>
<p>参考资料:<br><a href="https://github.com/nodejitsu/node-http-proxy" target="_blank" rel="external">node-http-proxy</a><br><a href="https://segmentfault.com/q/1010000004652320" target="_blank" rel="external">node http-proxy和nginx代理性能对比?</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP、-node-http-proxy、-nginx、-proxy/">HTTP、 node-http-proxy、 nginx、 proxy</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-HTTP 代理原理及实现（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/25/HTTP 代理原理及实现（一）/" class="article-date">
  	<time datetime="2016-11-25T07:56:21.000Z" itemprop="datePublished">2016-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/25/HTTP 代理原理及实现（一）/">HTTP 代理原理及实现（一）转载</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Web 代理是一种存在于网络中间的实体，提供各式各样的功能。现代网络系统中，Web 代理无处不在。我之前有关 HTTP 的博文中，多次提到了代理对 HTTP 请求及响应的影响。今天这篇文章，我打算谈谈 HTTP 代理本身的一些原理，以及如何用 Node.js 快速实现代理。</p>
<p>HTTP 代理存在两种形式，分别简单介绍如下：<br>第一种是 ［RFC 7230 - HTTP/1.1: Message Syntax and Routing］(<a href="https://tools.ietf.org/html/rfc7230)（即修订后的" target="_blank" rel="external">https://tools.ietf.org/html/rfc7230)（即修订后的</a> RFC 2616，HTTP/1.1 协议的第一部分）描述的普通代理。这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。</p>
<p>第二种是 <a href="https://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01" target="_blank" rel="external">Tunneling TCP based protocols through Web proxy servers</a>（通过 Web 代理服务器用隧道方式传输基于 TCP 的协议）描述的隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接，但 CONNECT 最开始并不是 RFC 2616 - HTTP/1.1 的一部分，直到 2014 年发布的 HTTP/1.1 修订版中，才增加了对 CONNECT 及隧道代理的描述，详见 <a href="https://tools.ietf.org/html/rfc7231#section-4.3.6" target="_blank" rel="external">RFC 7231 - HTTP/1.1: Semantics and Content</a>。实际上这种代理早就被广泛实现。</p>
<h2 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h2><p>第一种 Web 代理原理特别简单：</p>
<blockquote>
<p>HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。</p>
</blockquote>
<p>下面这张图片来自于《HTTP 权威指南》，直观地展示了上述行为：</p>
<p><img src="//st.imququ.com/i/webp/static/uploads/2015/11/web_proxy.png.webp" alt="HTTP 代理"></p>
<p>假如我通过代理访问 A 网站，对于 A 来说，它会把代理当做客户端，完全察觉不到真正客户端的存在，这实现了隐藏客户端 IP 的目的。当然代理也可以修改 HTTP 请求头部，通过<code>X-Forwarded-IP</code>这样的自定义头部告诉服务端真正的客户端 IP。但服务器无法验证这个自定义头部真的是由代理添加，还是客户端修改了请求头，所以从 HTTP 头部字段获取 IP 时，需要格外小心。这部分内容可以参考我之前的《<a href="https://imququ.com/post/x-forwarded-for-header-in-http.html" target="_blank" rel="external">HTTP 请求头中的 X-Forwarded-For</a>》这篇文章。</p>
<p>给浏览器显式的指定代理，需要手动修改浏览器或操作系统相关设置，或者指定 PAC（Proxy Auto-Configuration，自动配置代理）文件自动设置，还有些浏览器支持 WPAD（Web Proxy Autodiscovery Protocol，Web 代理自动发现协议）。显式指定浏览器代理这种方式一般称之为正向代理，浏览器启用正向代理后，会对 HTTP 请求报文做一些修改，来规避老旧代理服务器的一些问题，这部分内容可以参考我之前的《<a href="https://imququ.com/post/the-proxy-connection-header-in-http-request.html" target="_blank" rel="external">Http 请求头中的 Proxy-Connection</a>》这篇文章。</p>
<p>还有一种情况是访问 A 网站时，实际上访问的是代理，代理收到请求报文后，再向真正提供服务的服务器发起请求，并将响应转发给浏览器。这种情况一般被称之为反向代理，它可以用来隐藏服务器 IP 及端口。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。反向代理是 Web 系统最为常见的一种部署方式，例如本博客就是使用 Nginx 的<code>proxy_pass</code> 功能将浏览器请求转发到背后的 Node.js 服务。</p>
<p>了解完第一种代理的基本原理后，我们用 Node.js 实现一下它。只包含核心逻辑的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">function request(cReq, cRes) &#123;</span><br><span class="line">    var u = url.parse(cReq.url);</span><br><span class="line"></span><br><span class="line">    var options = &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || 80,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method     : cReq.method,</span><br><span class="line">        headers     : cReq.headers</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var pReq = http.request(options, function(pRes) &#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer().on(&apos;request&apos;, request).listen(8888, &apos;0.0.0.0&apos;);</span><br></pre></td></tr></table></figure>
<p>以上代码运行后，会在本地<code>8888</code>端口开启 HTTP 代理服务，这个服务从请求报文中解析出请求 URL 和其他必要参数，新建到服务端的请求，并把代理收到的请求转发给新建的请求，最后再把服务端响应返回给浏览器。修改浏览器的 HTTP 代理为<code>127.0.0.1:8888</code>后再访问 HTTP 网站，代理可以正常工作。</p>
<p>但是，使用我们这个代理服务后，HTTPS 网站完全无法访问，这是为什么呢？答案很简单，这个代理提供的是 HTTP 服务，根本没办法承载 HTTPS 服务。那么是否把这个代理改为 HTTPS 就可以了呢？显然也不可以，因为这种代理的本质是中间人，而 HTTPS 网站的证书认证机制是中间人劫持的克星。普通的 HTTPS 服务中，服务端不验证客户端的证书，中间人可以作为客户端与服务端成功完成 TLS 握手；但是中间人没有证书私钥，无论如何也无法伪造成服务端跟客户端建立 TLS 连接。当然如果你拥有证书私钥，代理证书对应的 HTTPS 网站当然就没问题了。</p>
<p>HTTP 抓包神器 Fiddler 的工作原理也是在本地开启 HTTP 代理服务，通过让浏览器流量走这个代理，从而实现显示和修改 HTTP 包的功能。如果要让 Fiddler 解密 HTTPS 包的内容，需要先将它自带的根证书导入到系统受信任的根证书列表中。一旦完成这一步，浏览器就会信任 Fiddler 后续的「伪造证书」，从而在浏览器和 Fiddler、Fiddler 和服务端之间都能成功建立 TLS 连接。而对于 Fiddler 这个节点来说，两端的 TLS 流量都是可以解密的。</p>
<p>如果我们不导入根证书，Fiddler 的 HTTP 代理还能代理 HTTPS 流量么？实践证明，不导入根证书，Fiddler 只是无法解密 HTTPS 流量，HTTPS 网站还是可以正常访问。这是如何做到的，这些 HTTPS 流量是否安全呢？这些问题将在下一节揭晓。</p>
<h2 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h2><p>第二种 Web 代理的原理也很简单：</p>
<blockquote>
<p>HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。</p>
</blockquote>
<p>下面这张图片同样来自于《HTTP 权威指南》，直观地展示了上述行为：</p>
<p><img src="//st.imququ.com/i/webp/static/uploads/2015/11/web_tunnel.png.webp" alt="HTTP 代理"></p>
<p>假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。对于 HTTPS 来说，客户端透过代理直接跟服务端进行 TLS 握手协商密钥，所以依然是安全的，下图中的抓包信息显示了这种场景：</p>
<p><img src="//st.imququ.com/i/webp/static/uploads/2015/11/wireshark_connect.png.webp" alt="HTTP 代理"></p>
<p>可以看到，浏览器与代理进行 TCP 握手之后，发起了 CONNECT 请求，报文起始行如下：</p>
<blockquote>
<p>CONNECT imququ.com:443 HTTP/1.1</p>
</blockquote>
<p>对于 CONNECT 请求来说，只是用来让代理创建 TCP 连接，所以只需要提供服务器域名及端口即可，并不需要具体的资源路径。代理收到这样的请求后，需要与服务端建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：</p>
<blockquote>
<p>HTTP/1.1 200 Connection Established</p>
</blockquote>
<p>浏览器收到了这个响应报文，就可以认为到服务端的 TCP 连接已经打通，后续直接往这个 TCP 连接写协议数据即可。通过 Wireshark 的 Follow TCP Steam 功能，可以清楚地看到浏览器和代理之间的数据传递：</p>
<p><img src="//st.imququ.com/i/webp/static/uploads/2015/11/wireshark_connect_detail.png.webp" alt="HTTP 代理"></p>
<p>可以看到，浏览器建立到服务端 TCP 连接产生的 HTTP 往返，完全是明文，这也是为什么 CONNECT 请求只需要提供域名和端口：如果发送了完整 URL、Cookie 等信息，会被中间人一览无余，降低了 HTTPS 的安全性。HTTP 代理承载的 HTTPS 流量，应用数据要等到 TLS 握手成功之后通过 Application Data 协议传输，中间节点无法得知用于流量加密的 master-secret，无法解密数据。而 CONNECT 暴露的域名和端口，对于普通的 HTTPS 请求来说，中间人一样可以拿到（IP 和端口很容易拿到，请求的域名可以通过 DNS Query 或者 TLS Client Hello 中的 Server Name Indication 拿到），所以这种方式并没有增加不安全性。</p>
<p>了解完原理后，再用 Node.js 实现一个支持 CONNECT 的代理也很简单。核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">function connect(cReq, cSock) &#123;</span><br><span class="line">    var u = url.parse(&apos;http://&apos; + cReq.url);</span><br><span class="line"></span><br><span class="line">    var pSock = net.connect(u.port, u.hostname, function() &#123;</span><br><span class="line">        cSock.write(&apos;HTTP/1.1 200 Connection Established\r\n\r\n&apos;);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer().on(&apos;connect&apos;, connect).listen(8888, &apos;0.0.0.0&apos;);</span><br></pre></td></tr></table></figure>
<p>以上代码运行后，会在本地<code>8888</code>端口开启 HTTP 代理服务，这个服务从 CONNECT 请求报文中解析出域名和端口，创建到服务端的 TCP 连接，并和 CONNECT 请求中的 TCP 连接串起来，最后再响应一个 Connection Established 响应。修改浏览器的 HTTP 代理为<code>127.0.0.1:8888</code>后再访问 HTTPS 网站，代理可以正常工作。</p>
<p>最后，将两种代理的实现代码合二为一，就可以得到全功能的 Proxy 程序了，全部代码在 50 行以内（当然异常什么的基本没考虑，这是我博客代码的一贯风格）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">function request(cReq, cRes) &#123;</span><br><span class="line">    var u = url.parse(cReq.url);</span><br><span class="line"></span><br><span class="line">    var options = &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || 80,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method     : cReq.method,</span><br><span class="line">        headers     : cReq.headers</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var pReq = http.request(options, function(pRes) &#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function connect(cReq, cSock) &#123;</span><br><span class="line">    var u = url.parse(&apos;http://&apos; + cReq.url);</span><br><span class="line"></span><br><span class="line">    var pSock = net.connect(u.port, u.hostname, function() &#123;</span><br><span class="line">        cSock.write(&apos;HTTP/1.1 200 Connection Established\r\n\r\n&apos;);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer()</span><br><span class="line">    .on(&apos;request&apos;, request)</span><br><span class="line">    .on(&apos;connect&apos;, connect)</span><br><span class="line">    .listen(8888, &apos;0.0.0.0&apos;);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，大部分浏览器显式配置了代理之后，只会让 HTTPS 网站走隧道代理，这是因为建立隧道需要耗费一次往返，能不用就尽量不用。但这并不代表 HTTP 请求不能走隧道代理，我们用 Node.js 写段程序验证下（先运行前面的代理服务）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    hostname : &apos;127.0.0.1&apos;,</span><br><span class="line">    port     : 8888,</span><br><span class="line">    path     : &apos;imququ.com:80&apos;,</span><br><span class="line">    method     : &apos;CONNECT&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var req = http.request(options);</span><br><span class="line"></span><br><span class="line">req.on(&apos;connect&apos;, function(res, socket) &#123;</span><br><span class="line">    socket.write(&apos;GET / HTTP/1.1\r\n&apos; +</span><br><span class="line">                 &apos;Host: imququ.com\r\n&apos; +</span><br><span class="line">                 &apos;Connection: Close\r\n&apos; +</span><br><span class="line">                 &apos;\r\n&apos;);</span><br><span class="line"></span><br><span class="line">    socket.on(&apos;data&apos;, function(chunk) &#123;</span><br><span class="line">        console.log(chunk.toString());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    socket.on(&apos;end&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;socket end.&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure></p>
<p>这段代码运行完，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Thu, 19 Nov 2015 15:57:47 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 178</span><br><span class="line">Connection: close</span><br><span class="line">Location: https://imququ.com/</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">socket end.</span><br></pre></td></tr></table></figure></p>
<p>可以看到，通过 CONNECT 让代理打开到目标服务器的 TCP 连接，用来承载 HTTP 流量也是完全没问题的。</p>
<p>最后，HTTP 的认证机制可以跟代理配合使用，使得必须输入正确的用户名和密码才能使用代理，这部分内容比较简单，这里略过。在本文第二部分，我打算谈谈如何把今天实现的代理改造为 HTTPS 代理，也就是如何让浏览器与代理之间的流量走 HTTPS 安全机制。。</p>
<p>参考资料:<br><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="external">HTTP 代理原理及实现（一）</a><br><a href="https://imququ.com/post/web-proxy-2.html" target="_blank" rel="external">HTTP 代理原理及实现（二）</a><br><a href="https://github.com/nodejitsu/node-http-proxy" target="_blank" rel="external">node-http-proxy</a><br><a href="https://segmentfault.com/q/1010000004652320" target="_blank" rel="external">node http-proxy和nginx代理性能对比?</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP、-node-http-proxy、-nginx、-proxy/">HTTP、 node-http-proxy、 nginx、 proxy</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-git查看文件提交记录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/15/git查看文件提交记录/" class="article-date">
  	<time datetime="2016-11-15T07:56:21.000Z" itemprop="datePublished">2016-11-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/15/git查看文件提交记录/">Git查看历史记录</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在项目工作中经常有遇到反复改动的情况，由此需要查看提交历史记录，来分析具体问题，使用<code>git log</code> 命令查看，可以很方便查到每次commit记录。</p>
<h2 id="一、git-log查看历史记录"><a href="#一、git-log查看历史记录" class="headerlink" title="一、git log查看历史记录"></a>一、git log查看历史记录</h2><p>当我们切换到Git库项目文件，使用<code>git log</code> 命令查看，查看每次commit历史记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>会出现类似如下结果，记录每次commit的md5值、时间说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">commit 3f54135d7ae20f26bbd41b105dcb6d14b2222a3a</span><br><span class="line">Author: pfan &lt;768065158@qq.com&gt;</span><br><span class="line">Date:   Fri Oct 28 15:18:55 2016 +0800</span><br><span class="line"></span><br><span class="line">    modify content.vue</span><br><span class="line"></span><br><span class="line">commit c522e1693db50a81588c59dc1b537315e86818b4</span><br><span class="line">Author: pfan &lt;768065158@qq.com&gt;</span><br><span class="line">Date:   Fri Oct 28 15:13:55 2016 +0800</span><br><span class="line"></span><br><span class="line">    modify flip</span><br><span class="line"></span><br><span class="line">commit 5bb0894e02048ca6c1a9fc6e9be4dac8f9af38e6</span><br><span class="line">Author: pfan &lt;768065158@qq.com&gt;</span><br><span class="line">Date:   Fri Oct 28 14:13:23 2016 +0800</span><br></pre></td></tr></table></figure></p>
<h2 id="二、查找具体文件更改记录"><a href="#二、查找具体文件更改记录" class="headerlink" title="二、查找具体文件更改记录"></a>二、查找具体文件更改记录</h2><p>使用<code>git log</code> 命令查看，很宽泛把所有的改动commit都罗列出来了，但往往我们的场景是需要显示指定文件被更改情况。那么，我们可以使用在git log后面加参数，更多参数使用请参详<a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="external">Git 基础 - 查看提交历史</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline 文件名</span><br></pre></td></tr></table></figure>
<p>结果，则会显示这个针对这个文件修改的md5值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">659ec40bfec5a0e29e268316bcff310aef3a4a4c fixed searchpage</span><br><span class="line">b388e7ed465561a00911139ef57b9077c1b7fb59 fix upload bug</span><br><span class="line">5b4fd6c62bd682d35783f7e99c15a8a15a84b158 form field</span><br><span class="line">163d6fd87059579c02a32bfc784c60fcef33d50c fixed svgfile 匹配 、上传作者、删除数组更新数据</span><br><span class="line">1b33156df3255415c60616e01794a69a839bdaef add search pager delete demo.html</span><br><span class="line">482b686cec440161bacd64af2a829aed54221ddc svg icon pushlish 1.0.2</span><br><span class="line">55c55cbd5898242c5add2b762949c8a3336c59fe add svgicon_platform</span><br></pre></td></tr></table></figure></p>
<h2 id="三、git-show查看具体改动"><a href="#三、git-show查看具体改动" class="headerlink" title="三、git show查看具体改动"></a>三、git show查看具体改动</h2><p>当我们拿到改动的commit md5哈希值时，可使用<code>git show</code>即可显示具体的某次的改动的修改，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 3f54135d7ae20f26bbd41b105dcb6d14b2222a3a</span><br></pre></td></tr></table></figure>
<p>结果就会展现改动记录以及具体代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commit 3f54135d7ae20f26bbd41b105dcb6d14b2222a3a</span><br><span class="line">Author: pfan &lt;768065158@qq.com&gt;</span><br><span class="line">Date:   Fri Oct 28 15:18:55 2016 +0800</span><br><span class="line"></span><br><span class="line">    modify content.vue</span><br><span class="line"></span><br><span class="line">diff --git a/dist/index.html b/dist/index.html</span><br><span class="line">index 1f54ffa..0416d15 100644</span><br><span class="line">--- a/dist/index.html</span><br><span class="line">+++ b/dist/index.html</span><br></pre></td></tr></table></figure></p>
<h2 id="四、扩展删除缓存，重新按gitignore走"><a href="#四、扩展删除缓存，重新按gitignore走" class="headerlink" title="四、扩展删除缓存，重新按gitignore走"></a>四、扩展删除缓存，重新按gitignore走</h2><p>请保证，所有分支已经提交成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .   //删除缓存文件，但不删除文件</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;update .gitignore&apos;</span><br></pre></td></tr></table></figure>
<p>参考资料:<br><a href="http://www.cnblogs.com/flyme/archive/2011/11/28/2265899.html" target="_blank" rel="external">git查看某个文件的修改历史</a><br><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="external">Git 基础 - 查看提交历史</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git，Git查看历史记录/">Git，Git查看历史记录</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
    <article id="post-CSS3D-陀螺仪、重力感应" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/13/CSS3D-陀螺仪、重力感应/" class="article-date">
  	<time datetime="2016-11-13T07:56:21.000Z" itemprop="datePublished">2016-11-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/13/CSS3D-陀螺仪、重力感应/">CSS3D-陀螺仪、重力感应</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大家可能还记得前段时间淘宝造物节的宣传动画效果,让自己对CSS 360全景更充满好奇之心。尽从效果上，就吸引了大家不少的眼球，当然大家更期待的是如何能实现这样的效果。那么我们来开始一起探讨这方面的事情。</p>
<p>在具备独立完成这样的效果之前，咱们需要对几个知识点要有所了解：</p>
<ul>
<li>设备的摄像头Camera(Camera API)</li>
<li>陀螺仪、重力感应</li>
<li>CSS 3D （CSS3 Transform 3D）</li>
</ul>
<p>而这些都涉及很多的知识面，今天我们先来介绍其中有关于陀螺仪相在的知识点。</p>
<h2 id="HTML5-Orientation"><a href="#HTML5-Orientation" class="headerlink" title="HTML5 Orientation"></a>HTML5 Orientation</h2><p>HTML5 Orientation是HTML5中一个非常酷的特性，它主要用来检测智能设备（手机、平板等）的运动方向。在现在的移动端开发中已给用户带来更良好的体验，也在很多项目中发挥了重要的重用。</p>
<p>目前在以下场景中常能看到其相关的身影：</p>
<blockquote>
<p>控制游戏:Web游戏应用监控设备方向，并将其解释为控制屏幕上的精灵在某方向上的倾斜。<br>手势识别:Web应用监控设备的加速，并将其应用于信号处理，以便识别特定首饰。距离说明，使用摇晃手势清除web表单。<br>地图:Web地图应用使用设备方向，将地图与实际情况对齐。</p>
</blockquote>
<p>在使用设备运动方向(Device Orientation)API之前，先得确保浏览器支持这些API。要得到相关的数据，可以直接从Can I Use.com得到相关数据：</p>
<p>当然，用户是不知道自己的浏览器是否支持，所以在我们的代码中要做一些事情，就是在使用运动方向API之前先做一些检测，如果支持就使用该API，如果不支持，就提供相关的提示信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (window.DeviceOrientationEvent) &#123;</span><br><span class="line">    //  支持DeviceOrientation API写在这里</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&quot;对不起，您的浏览器还不支持Device Orientation!!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不要急着这里面的代码怎么写，先来了解一些相关的知识点。帮助更好的理解设备方向(Device Orientation)和更好的使用好设备方向。</p>
<h2 id="地球坐标系统"><a href="#地球坐标系统" class="headerlink" title="地球坐标系统"></a>地球坐标系统</h2><p>先来看一张地球坐标系统的图：</p>
<p><img src="http://img.pfan123.com/deviceo1.png" alt="地球坐标系统"></p>
<p>地心地固坐标系（Earth-Centered, Earth-Fixed，简称ECEF）简称地心坐标系，是一种以地心为原点的地固坐标系（也称地球坐标系），是一种笛卡儿坐标系。原点 O (0,0,0)为地球质心，z 轴与地轴平行指向北极点，x轴指向本初子午线与赤道的交点，y 轴垂直于xOz平面(即东经90度与赤道的交点)构成右手坐标系。</p>
<p>地球坐标系统是由x、y、z三个轴组成，基于重力和标准磁场方向。简单点讲，地球坐标系统是一个位于用户位置的东、北、上系，其拥有3个轴，地面相切与1984世界测地系统的Spheriod的用户所在位置。</p>
<blockquote>
<p>东(x)在地面上，垂直于北轴，向东为正 (东西方向)<br>北(y)在地面上，向正北为正（指向北极）（南北方向）<br>上(z)垂直于地面，向上为正（上下方向）</p>
</blockquote>
<p>对于一个移动设备，例如电话或平板，设备坐标系的定义于屏幕的标准方向相关。这意味着类似于键盘的滑动元素没有展开、类似于显示器的选择元素折叠至 其默认位置。如果在设备旋转或展开滑动键盘时屏幕方向发生变化，这不会影响关于设备的坐标系的方向。用户希望获得这些屏幕方向的变化可以使用现有的orientationchange事件。对于膝上电脑，设备的坐标系定义于集成键盘。</p>
<blockquote>
<p>x在屏幕或键盘平面上，屏幕或键盘的右侧为正。<br>y在屏幕或键盘屏幕上，屏幕或键盘的上方为正。<br>z垂直于屏幕或键盘屏幕，离开屏幕或键盘为正。</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="http://img.pfan123.com/deviceo2.png" alt="地球坐标系统"></p>
<p>从地球坐标系到设备坐标系的转变必须按照下列系统转换。旋转必须使用右手规则，即正向沿一个轴旋转为从该轴的方向看顺时针旋转。从两个系重合开始，旋转应用下列规则：</p>
<blockquote>
<p>以设备坐标系z轴为轴，旋转alpha度。alpha的作用域为(0, 360)。<br>以设备坐标系x轴为轴，旋转beta度。beta的作用域为(-180, 180)。<br>已设备坐标系y轴为轴，旋转gamma度。gamma的作用域为(-90, 90)。</p>
</blockquote>
<p>如下图所示：<br><img src="http://img.pfan123.com/deviceo3.png" alt="地球坐标系统"></p>
<h2 id="Alpha-Beta-和-Gamma-角"><a href="#Alpha-Beta-和-Gamma-角" class="headerlink" title="Alpha, Beta 和 Gamma 角"></a>Alpha, Beta 和 Gamma 角</h2><p>Alpha(α), Beta（β） 和 Gamma（γ）角也称之为旋转数据。旋转数据作为欧拉角(Euler Angle)返回，是设备坐标系和地球坐标系之间的差异值。</p>
<p>在解释Alpha、Beta和Gamma这三个角之前，我们需要定义存在的空间。如下图所示，展示了移动设备上使用的三维坐标系统:</p>
<p><img src="http://img.pfan123.com/deviceo4.png" alt="地球坐标系统"></p>
<p>在手机或者平板上，设备定位方向是基于屏幕方向的。对于手机和平板来说，他们都是基于纵向模式的设备，对于台式机或笔记本电脑来说，他们的定位方向和键盘有关。</p>
<h3 id="Alpha（α）角"><a href="#Alpha（α）角" class="headerlink" title="Alpha（α）角"></a>Alpha（α）角</h3><p>Alpha（α）角代表的是z轴。因此，任何沿着z轴旋转都会使用Alpha(α)角变化。Alpha(α)的变化范围是(0~360)度之间。当α = 0时，设备是直接每日向地球的北极。下图显示了α旋转。</p>
<p><img src="http://img.pfan123.com/deviceo5.png" alt="地球坐标系统"></p>
<p>设备逆时针旋转，Alpha(α)值增加。</p>
<h3 id="Beta（β）角"><a href="#Beta（β）角" class="headerlink" title="Beta（β）角"></a>Beta（β）角</h3><p>Beta（β）角代表的是x轴。设备绕着x轴旋转将导致Beta（β）角变化。Beta（β）的变化范围是(-180 ~ 180)度之间。当设备平行于地球表面时β = 0，比如说，你把手机平放在桌面上。下图显示了β旋转:</p>
<p><img src="http://img.pfan123.com/deviceo6.png" alt="地球坐标系统"></p>
<h3 id="Gamma-γ-角"><a href="#Gamma-γ-角" class="headerlink" title="Gamma(γ)角"></a>Gamma(γ)角</h3><p>Gamma(γ)角代表的是y轴。设备绕着y轴旋转将导致Gamma(γ)角变化。Gamma(γ)角的变化范围是(-90 ~ 90)度。当设备平行于地球表面时γ = 0。下图显示了γ旋转:</p>
<p><img src="http://img.pfan123.com/deviceo7.png" alt="地球坐标系统"></p>
<p>上面简单介绍了Alpha(α), Beta（β） 和 Gamma（γ）角。从网上整了几张有关于Beta（β） 和 Gamma（γ）角旋转的数据示意图：</p>
<h4 id="Beta（β）上下翻动"><a href="#Beta（β）上下翻动" class="headerlink" title="Beta（β）上下翻动"></a>Beta（β）上下翻动</h4><p><img src="http://img.pfan123.com/deviceo8.jpg" alt="地球坐标系统"></p>
<p>从上面的图片中，不难观察出相应的结果，在向上翻动手势过程中：</p>
<blockquote>
<p>Beta(β)值有较明显变化，由初始值变化至约90度<br>Gamma(γ) 和 Alpha(α) 绝对值之差趋近于0<br>Beta(β)开始变化早于Gamm(γ)和Alpha(α)</p>
</blockquote>
<h4 id="Gamma-γ-左右翻动"><a href="#Gamma-γ-左右翻动" class="headerlink" title="Gamma(γ)左右翻动"></a>Gamma(γ)左右翻动</h4><p><img src="http://img.pfan123.com/deviceo9.jpg" alt="地球坐标系统"></p>
<p>从图中，很明显的可以看出，Gamma(γ)做着优雅的 “正弦曲线”变化，而Alpha(α)和Beta(β)基本保持着不变， 所以我们可以得出以下结论：</p>
<blockquote>
<p>Alpha(α)和Beta(β)值基本保持不变<br>向左翻转时，Gamma(γ)在负数方向做0到约-90到0的变化<br>向右翻转时，Gamma(γ)在正数方向做0到90到0的变化</p>
</blockquote>
<p>综合上述，我们可以用图来更好阐述设备坐标和地球坐标之间的关系：</p>
<p><img src="http://img.pfan123.com/deviceo10.png" alt="地球坐标系统"></p>
<p>设备的初始位置，地球（XYZ）与设备（xyz）坐标系重合。</p>
<p><img src="http://img.pfan123.com/deviceo11.png" alt="地球坐标系统"></p>
<p>设备以z轴为轴，旋转Alpha(α)度，原坐标x、y轴显示为x0、y0。</p>
<p><img src="http://img.pfan123.com/deviceo12.png" alt="地球坐标系统"></p>
<p>设备以x轴为轴，旋转Beta(β)度，原坐标y、z轴显示为y0、z0。</p>
<p><img src="http://img.pfan123.com/deviceo13.png" alt="地球坐标系统"></p>
<p>设备以y轴为轴，旋转Beta(β)度，原坐标x、z轴显示为x0、z0。</p>
<p>因此，Alpha(α)、Beta(β)和Gamma(γ)组成一组Z-X’-Y’’式的固有Tait-Bryan角度。注意这里对角度的选择遵循数学惯例，但这意味着Alpha(α)与罗盘指向相反。这还意味着这些角度不匹配车辆动力学中的roll-pitch-yaw惯例。</p>
<p>对于不能提供三个角度绝对值的实现，作为替代，可以提供关于任意方向的相对值。在这种情况下，必须设absolute属性为false，否则必须设absolute属性为true。</p>
<p>对于不能提供所有三个角度的实现，其必须设未知的角度的值为null。如果提供了某一角度，必须恰当的设置absolute属性。如果实现不能提供任何方向信息，则触发事件时所有属性都必须被设为null。</p>
<h2 id="什么是重力感应"><a href="#什么是重力感应" class="headerlink" title="什么是重力感应"></a>什么是重力感应</h2><p>说到重力感应有一个东西不得不提，那就是就是陀螺仪，陀螺仪就是内部有一个陀螺，陀螺仪一旦开始旋转，由于轮子的角动量，陀螺仪有抗拒方向改变的特性，它的轴由于陀螺效应始终与初始方向平行，这样就可以通过与初始方向的偏差计算出实际方向。</p>
<h3 id="deviceorientation事件"><a href="#deviceorientation事件" class="headerlink" title="deviceorientation事件"></a>deviceorientation事件</h3><p>设备方向事件会返回设备旋转角度数据，如果手机或者笔记本电脑有指南针的话，返回数据中还会包括设备当前的朝向。在HTML5 OrientationAPI提供了三个相应的DOM事件:</p>
<blockquote>
<p>deviceorientation，其提供设备的物理方向信息，表示为一系列本地坐标系的旋角<br>devicemotion，其提供设备的加速信息，表示为定义在设备上的坐标系中的卡尔迪坐标。其还提供了设备在坐标系中的自转速率。若可行的话，事件应该提供设备重心处的加速信息。<br>compassneedscalibration,其用于通知Web站点使用罗盘信息校准上述事件。</p>
</blockquote>
<h3 id="何时使用设备方向事件"><a href="#何时使用设备方向事件" class="headerlink" title="何时使用设备方向事件"></a>何时使用设备方向事件</h3><p>设备方向事件有几种使用场景，例如：</p>
<blockquote>
<p>更新移动的用户的地图<br>UI调整，像是增加Paralax（视差滚动：指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验）效果<br>结合地理定位，用于导航</p>
</blockquote>
<h3 id="检测和监听方向事件"><a href="#检测和监听方向事件" class="headerlink" title="检测和监听方向事件"></a>检测和监听方向事件</h3><p>在监听DeviceOrientationEvent事件前，我们首先要检查浏览器是否支持。然后再在window中增加deviceorientation事件监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (window.DeviceOrientationEvent) &#123;</span><br><span class="line">    window.addEventListener(&apos;deviceorientation&apos;, deviceOrientationHandler, false);</span><br><span class="line">    document.getElementById(&quot;doeSupported&quot;).innerText = &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理设备方向事件"><a href="#处理设备方向事件" class="headerlink" title="处理设备方向事件"></a>处理设备方向事件</h3><p>当设备移动或者方向改变时，设备方向事件就会被触发。它会返回当前位置相对于地球坐标的差值。</p>
<p>事件通常会返回Alipha、Beta和Gamma三个值。在移动端Safari浏览器中，还会返回webkitCompassHeading属性值，这个属性值与指南针（compass）的导向有关。</p>
<h3 id="检测和监听移动事件"><a href="#检测和监听移动事件" class="headerlink" title="检测和监听移动事件"></a>检测和监听移动事件</h3><p>监听DeviceMotionEvents事件前，首先要检查浏览器是否支持，然后再在window上监听devicemotion事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (window.DeviceMotionEvent) &#123;</span><br><span class="line">    window.addEventListener(&quot;devicemotion&quot;, deviceMotionHandler);</span><br><span class="line">    setTimeout(stopJump, 3*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理设备移动事件"><a href="#处理设备移动事件" class="headerlink" title="处理设备移动事件"></a>处理设备移动事件</h3><p>当需要每隔一定时间返回设备的旋转速率（以度每秒为单位）或者移动速率数据时，设备移动事件就会被触发。有些设备没有可以排除重力影响的硬件装置。</p>
<p>该事件返回4个属性值，包括accelerationIncludingGravity、acceleration。</p>
<p>让我们来看一个在平坦桌面上，屏幕朝上的手机的例子。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>旋转</th>
<th>加速(m/s2)度</th>
<th>重力加速度(m/s2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>不移动</td>
<td>[0, 0, 0]</td>
<td>[0, 0, 0]</td>
<td>[0, 0, 9.8]</td>
</tr>
<tr>
<td>朝着天空移动</td>
<td>[0, 0, 0]</td>
<td>[0, 0, 5]</td>
<td>[0, 0, 14.81]</td>
</tr>
<tr>
<td>向右侧移动</td>
<td>[0, 0, 0]</td>
<td>[3, 0, 0]</td>
<td>[3, 0, 9.81]</td>
</tr>
<tr>
<td>向上且向右移动</td>
<td>[0, 0, 0]</td>
<td>[5, 0, 5]</td>
<td>[5, 0, 14.81]</td>
</tr>
</tbody>
</table>
<p>相反，如果手机被握住，保持手机屏幕和地面垂直，且屏幕面对观察者：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>旋转</th>
<th>加速(m/s2)度</th>
<th>重力加速度(m/s2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>不移动</td>
<td>[0, 0, 0]</td>
<td>[0, 0, 0]</td>
<td>[0, 9.81, 0]</td>
</tr>
<tr>
<td>朝着天空移动</td>
<td>[0, 0, 0]</td>
<td>[0, 5, 0]</td>
<td>[0, 14.81, 0]</td>
</tr>
<tr>
<td>向右侧移动</td>
<td>[0, 0, 0]</td>
<td>[3, 0, 0]</td>
<td>[3, 9.81, 0]</td>
</tr>
<tr>
<td>向上且向右移动</td>
<td>[0, 0, 0]</td>
<td>[5, 5, 0]</td>
<td>[5, 14.81, 0]</td>
</tr>
</tbody>
</table>
<h3 id="有关于deviceorientation事件常用方法"><a href="#有关于deviceorientation事件常用方法" class="headerlink" title="有关于deviceorientation事件常用方法:"></a>有关于deviceorientation事件常用方法:</h3><p>注册一个deviceorientation事件的接收器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;deviceorientation&quot;, function(event) &#123;</span><br><span class="line">    // 处理event.alpha、event.beta及event.gamma</span><br><span class="line">&#125;, true);</span><br></pre></td></tr></table></figure>
<p>将设备放置在水平表面，屏幕顶端指向西方，则其方向信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    alpha: 90,</span><br><span class="line">    beta: 0,</span><br><span class="line">    gamma: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  为了获得罗盘指向，可以简单的使用360度减去alpha。若设被平行于水平表面，其罗盘指向为(360 - alpha)。若用户手持设备，屏幕处于一个垂直平面且屏幕顶端指向上方。beta的值为90，alpha和gamma无关。</p>
<p>用户手持设备，面向alpha角度，屏幕处于一个垂直屏幕，屏幕顶端指向右方，则其方向信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    alpha: 270 - alpha,</span><br><span class="line">    beta: 0,</span><br><span class="line">    gamma: 90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  只用自定义界面通知用户校准罗盘：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;compassneedscalibration&quot;, function(event) &#123;</span><br><span class="line">    alert(&apos;您的罗盘需要校准，请将设备沿数字8方向移动。&apos;);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;, true);</span><br><span class="line">注册一个devicemotion时间的接收器：</span><br><span class="line">window.addEventListener(&quot;devicemotion&quot;, function(event) &#123;</span><br><span class="line">    // 处理event.acceleration、event.accelerationIncludingGravity、</span><br><span class="line">    // event.rotationRate和event.interval</span><br><span class="line">&#125;, true);</span><br></pre></td></tr></table></figure>
<p>将设备放置在水平表面，屏幕向上，acceleration为零，则其accelerationIncludingGravity信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0,</span><br><span class="line">    z: 9.81</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设备做自由落体，屏幕水平向上，accelerationIncludingGravity为零，则其acceleration信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0,</span><br><span class="line">    z: -9.81</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将设备安置于车辆至上，屏幕处于一个垂直平面，顶端向上，面向车辆后部。车辆行驶速度为v，向右侧进行半径为r的转弯。设备记录acceleration和accelerationIncludingGravity在位置x处的情况，同时设备还会记录rotationRate.gamma的负值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    acceleration: &#123;</span><br><span class="line">        x: v^2/r, </span><br><span class="line">        y: 0, </span><br><span class="line">        z: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    accelerationIncludingGravity: &#123;</span><br><span class="line">        x: v^2/r, </span><br><span class="line">        y: 0, </span><br><span class="line">        z: 9.81</span><br><span class="line">    &#125;,</span><br><span class="line">    rotationRate: &#123;</span><br><span class="line">        alpha: 0, </span><br><span class="line">        beta: 0, </span><br><span class="line">        gamma: -v/r*180/pi</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>旋转的立方体</p>
<p>既然有HTML5 Orientation这样的API，那么我们之前制作的CSS 3D盒子就可以在称动设备上做一些重力感应的效果，比如旋转你的手机，让立方体动起来。接下来，来看一个这方面的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;platform&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;dice&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;side front&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;dot center&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side front inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side top&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;dot dtop dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dbottom dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side top inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side right&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;dot dtop dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot center&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dbottom dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side right inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side left&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;dot dtop dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dtop dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dbottom dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dbottom dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side left inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side bottom&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;dot center&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dtop dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dtop dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dbottom dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dbottom dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side bottom inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side back&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;dot dtop dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dtop dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dbottom dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot dbottom dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot center dleft&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;dot center dright&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;side back inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">(function() &#123;</span><br><span class="line">    var space = document.getElementById(&apos;dice&apos;);</span><br><span class="line">    if (window.DeviceOrientationEvent) &#123;</span><br><span class="line"></span><br><span class="line">        window.addEventListener(&apos;deviceorientation&apos;, function(event) &#123;</span><br><span class="line">            var alpha = event.alpha,</span><br><span class="line">                beta = event.beta,</span><br><span class="line">                gamma = event.gamma;</span><br><span class="line"></span><br><span class="line">            space.style.webkitTransform = &apos;rotateX(&apos; + beta + &apos;deg) rotateY(&apos; + gamma + &apos;deg) rotateZ(&apos; + alpha + &apos;deg)&apos;;</span><br><span class="line">            space.style.transform = &apos;rotateX(&apos; + beta + &apos;deg) rotateY(&apos; + gamma + &apos;deg) rotateZ(&apos; + alpha + &apos;deg)&apos;;</span><br><span class="line">            space.style.mozTransform = &apos;rotateX(&apos; + beta + &apos;deg) rotateY(&apos; + gamma + &apos;deg) rotateZ(&apos; + alpha + &apos;deg)&apos;;</span><br><span class="line"></span><br><span class="line">        &#125;, false);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        document.querySelector(&apos;body&apos;).innerHTML = &apos;你的瀏覽器不支援喔&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>参考资料:<br><a href="https://www.w3.org/html/ig/zh/wiki/DeviceOrientation%E4%BA%8B%E4%BB%B6%E8%A7%84%E8%8C%83#deviceorientation_.E4.BA.8B.E4.BB.B6" target="_blank" rel="external">W3C DeviceOrientation事件规范</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Detecting_device_orientation" target="_blank" rel="external">检测设备方向</a><br><a href="http://www.oxxostudio.tw/articles/201506/html5-device-orientation.html" target="_blank" rel="external">HTML5 控制裝置陀螺儀 ( 三軸 )</a><br><a href="http://www.haorooms.com/post/html5_DeviceMotionEvent" target="_blank" rel="external">html5重力感应事件之DeviceMotionEvent</a><br><a href="http://www.cnblogs.com/summer_shao/p/webevent.html" target="_blank" rel="external">移动终端学习2：触屏原生js事件及重力感应</a><br><a href="http://am-team.github.io/amg/dev-exp-doc.html#移动开发事件" target="_blank" rel="external">移动开发事件</a><br><a href="https://github.com/hoosin/mobile-web-favorites" target="_blank" rel="external">移动端资源集合</a><br><a href="https://segmentfault.com/a/1190000003749966" target="_blank" rel="external">html5实现微信摇一摇功能</a><br><a href="https://segmentfault.com/a/1190000004324305" target="_blank" rel="external">HTML5摇一摇（上）—如何判断设备摇动</a><br><a href="http://www.w3cplus.com/animation/html5-device-orientation-basic-intro.html" target="_blank" rel="external">陀螺仪的基础知识</a></p>

      
    </div>

    <!-- S 打赏模块 -->
    <div class="pfan_payment" style="max-width: 500px;margin: 0 auto">
        <img src="http://img.pfan123.com/payment.png" alt="" style="width: 100%;height: 10%;">
    </div>
    <!-- E 打赏模块 -->


    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deviceorientation、orientationchange-重力感应-CSS3D/">deviceorientation、orientationchange 重力感应 CSS3D</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
    
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 pfan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>